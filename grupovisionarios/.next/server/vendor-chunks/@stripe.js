"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@stripe";
exports.ids = ["vendor-chunks/@stripe"];
exports.modules = {

/***/ "(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressElement: () => (/* binding */ AddressElement),\n/* harmony export */   AffirmMessageElement: () => (/* binding */ AffirmMessageElement),\n/* harmony export */   AfterpayClearpayMessageElement: () => (/* binding */ AfterpayClearpayMessageElement),\n/* harmony export */   AuBankAccountElement: () => (/* binding */ AuBankAccountElement),\n/* harmony export */   CardCvcElement: () => (/* binding */ CardCvcElement),\n/* harmony export */   CardElement: () => (/* binding */ CardElement),\n/* harmony export */   CardExpiryElement: () => (/* binding */ CardExpiryElement),\n/* harmony export */   CardNumberElement: () => (/* binding */ CardNumberElement),\n/* harmony export */   CheckoutProvider: () => (/* binding */ CheckoutProvider),\n/* harmony export */   CurrencySelectorElement: () => (/* binding */ CurrencySelectorElement),\n/* harmony export */   Elements: () => (/* binding */ Elements),\n/* harmony export */   ElementsConsumer: () => (/* binding */ ElementsConsumer),\n/* harmony export */   EmbeddedCheckout: () => (/* binding */ EmbeddedCheckout),\n/* harmony export */   EmbeddedCheckoutProvider: () => (/* binding */ EmbeddedCheckoutProvider),\n/* harmony export */   EpsBankElement: () => (/* binding */ EpsBankElement),\n/* harmony export */   ExpressCheckoutElement: () => (/* binding */ ExpressCheckoutElement),\n/* harmony export */   FpxBankElement: () => (/* binding */ FpxBankElement),\n/* harmony export */   IbanElement: () => (/* binding */ IbanElement),\n/* harmony export */   IdealBankElement: () => (/* binding */ IdealBankElement),\n/* harmony export */   LinkAuthenticationElement: () => (/* binding */ LinkAuthenticationElement),\n/* harmony export */   P24BankElement: () => (/* binding */ P24BankElement),\n/* harmony export */   PaymentElement: () => (/* binding */ PaymentElement),\n/* harmony export */   PaymentMethodMessagingElement: () => (/* binding */ PaymentMethodMessagingElement),\n/* harmony export */   PaymentRequestButtonElement: () => (/* binding */ PaymentRequestButtonElement),\n/* harmony export */   ShippingAddressElement: () => (/* binding */ ShippingAddressElement),\n/* harmony export */   useCheckout: () => (/* binding */ useCheckout),\n/* harmony export */   useElements: () => (/* binding */ useElements),\n/* harmony export */   useStripe: () => (/* binding */ useStripe)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar useAttachEvent = function useAttachEvent(element, event, cb) {\n  var cbDefined = !!cb;\n  var cbRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(cb); // In many integrations the callback prop changes on each render.\n  // Using a ref saves us from calling element.on/.off every render.\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    cbRef.current = cb;\n  }, [cb]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (!cbDefined || !element) {\n      return function () {};\n    }\n\n    var decoratedCb = function decoratedCb() {\n      if (cbRef.current) {\n        cbRef.current.apply(cbRef, arguments);\n      }\n    };\n\n    element.on(event, decoratedCb);\n    return function () {\n      element.off(event, decoratedCb);\n    };\n  }, [cbDefined, event, element, cbRef]);\n};\n\nvar usePrevious = function usePrevious(value) {\n  var ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n};\n\nvar isUnknownObject = function isUnknownObject(raw) {\n  return raw !== null && _typeof(raw) === 'object';\n};\nvar isPromise = function isPromise(raw) {\n  return isUnknownObject(raw) && typeof raw.then === 'function';\n}; // We are using types to enforce the `stripe` prop in this lib,\n// but in an untyped integration `stripe` could be anything, so we need\n// to do some sanity validation to prevent type errors.\n\nvar isStripe = function isStripe(raw) {\n  return isUnknownObject(raw) && typeof raw.elements === 'function' && typeof raw.createToken === 'function' && typeof raw.createPaymentMethod === 'function' && typeof raw.confirmCardPayment === 'function';\n};\n\nvar PLAIN_OBJECT_STR = '[object Object]';\nvar isEqual = function isEqual(left, right) {\n  if (!isUnknownObject(left) || !isUnknownObject(right)) {\n    return left === right;\n  }\n\n  var leftArray = Array.isArray(left);\n  var rightArray = Array.isArray(right);\n  if (leftArray !== rightArray) return false;\n  var leftPlainObject = Object.prototype.toString.call(left) === PLAIN_OBJECT_STR;\n  var rightPlainObject = Object.prototype.toString.call(right) === PLAIN_OBJECT_STR;\n  if (leftPlainObject !== rightPlainObject) return false; // not sure what sort of special object this is (regexp is one option), so\n  // fallback to reference check.\n\n  if (!leftPlainObject && !leftArray) return left === right;\n  var leftKeys = Object.keys(left);\n  var rightKeys = Object.keys(right);\n  if (leftKeys.length !== rightKeys.length) return false;\n  var keySet = {};\n\n  for (var i = 0; i < leftKeys.length; i += 1) {\n    keySet[leftKeys[i]] = true;\n  }\n\n  for (var _i = 0; _i < rightKeys.length; _i += 1) {\n    keySet[rightKeys[_i]] = true;\n  }\n\n  var allKeys = Object.keys(keySet);\n\n  if (allKeys.length !== leftKeys.length) {\n    return false;\n  }\n\n  var l = left;\n  var r = right;\n\n  var pred = function pred(key) {\n    return isEqual(l[key], r[key]);\n  };\n\n  return allKeys.every(pred);\n};\n\nvar extractAllowedOptionsUpdates = function extractAllowedOptionsUpdates(options, prevOptions, immutableKeys) {\n  if (!isUnknownObject(options)) {\n    return null;\n  }\n\n  return Object.keys(options).reduce(function (newOptions, key) {\n    var isUpdated = !isUnknownObject(prevOptions) || !isEqual(options[key], prevOptions[key]);\n\n    if (immutableKeys.includes(key)) {\n      if (isUpdated) {\n        console.warn(\"Unsupported prop change: options.\".concat(key, \" is not a mutable property.\"));\n      }\n\n      return newOptions;\n    }\n\n    if (!isUpdated) {\n      return newOptions;\n    }\n\n    return _objectSpread2(_objectSpread2({}, newOptions || {}), {}, _defineProperty({}, key, options[key]));\n  }, null);\n};\n\nvar INVALID_STRIPE_ERROR$2 = 'Invalid prop `stripe` supplied to `Elements`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.'; // We are using types to enforce the `stripe` prop in this lib, but in a real\n// integration `stripe` could be anything, so we need to do some sanity\n// validation to prevent type errors.\n\nvar validateStripe = function validateStripe(maybeStripe) {\n  var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n\n  if (maybeStripe === null || isStripe(maybeStripe)) {\n    return maybeStripe;\n  }\n\n  throw new Error(errorMsg);\n};\n\nvar parseStripeProp = function parseStripeProp(raw) {\n  var errorMsg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : INVALID_STRIPE_ERROR$2;\n\n  if (isPromise(raw)) {\n    return {\n      tag: 'async',\n      stripePromise: Promise.resolve(raw).then(function (result) {\n        return validateStripe(result, errorMsg);\n      })\n    };\n  }\n\n  var stripe = validateStripe(raw, errorMsg);\n\n  if (stripe === null) {\n    return {\n      tag: 'empty'\n    };\n  }\n\n  return {\n    tag: 'sync',\n    stripe: stripe\n  };\n};\n\nvar registerWithStripeJs = function registerWithStripeJs(stripe) {\n  if (!stripe || !stripe._registerWrapper || !stripe.registerAppInfo) {\n    return;\n  }\n\n  stripe._registerWrapper({\n    name: 'react-stripe-js',\n    version: \"3.7.0\"\n  });\n\n  stripe.registerAppInfo({\n    name: 'react-stripe-js',\n    version: \"3.7.0\",\n    url: 'https://stripe.com/docs/stripe-js/react'\n  });\n};\n\nvar ElementsContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nElementsContext.displayName = 'ElementsContext';\nvar parseElementsContext = function parseElementsContext(ctx, useCase) {\n  if (!ctx) {\n    throw new Error(\"Could not find Elements context; You need to wrap the part of your app that \".concat(useCase, \" in an <Elements> provider.\"));\n  }\n\n  return ctx;\n};\n/**\n * The `Elements` provider allows you to use [Element components](https://stripe.com/docs/stripe-js/react#element-components) and access the [Stripe object](https://stripe.com/docs/js/initializing) in any nested component.\n * Render an `Elements` provider at the root of your React app so that it is available everywhere you need it.\n *\n * To use the `Elements` provider, call `loadStripe` from `@stripe/stripe-js` with your publishable key.\n * The `loadStripe` function will asynchronously load the Stripe.js script and initialize a `Stripe` object.\n * Pass the returned `Promise` to `Elements`.\n *\n * @docs https://stripe.com/docs/stripe-js/react#elements-provider\n */\n\nvar Elements = function Elements(_ref) {\n  var rawStripeProp = _ref.stripe,\n      options = _ref.options,\n      children = _ref.children;\n  var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return parseStripeProp(rawStripeProp);\n  }, [rawStripeProp]); // For a sync stripe instance, initialize into context\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(function () {\n    return {\n      stripe: parsed.tag === 'sync' ? parsed.stripe : null,\n      elements: parsed.tag === 'sync' ? parsed.stripe.elements(options) : null\n    };\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      ctx = _React$useState2[0],\n      setContext = _React$useState2[1];\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var isMounted = true;\n\n    var safeSetContext = function safeSetContext(stripe) {\n      setContext(function (ctx) {\n        // no-op if we already have a stripe instance (https://github.com/stripe/react-stripe-js/issues/296)\n        if (ctx.stripe) return ctx;\n        return {\n          stripe: stripe,\n          elements: stripe.elements(options)\n        };\n      });\n    }; // For an async stripePromise, store it in context once resolved\n\n\n    if (parsed.tag === 'async' && !ctx.stripe) {\n      parsed.stripePromise.then(function (stripe) {\n        if (stripe && isMounted) {\n          // Only update Elements context if the component is still mounted\n          // and stripe is not null. We allow stripe to be null to make\n          // handling SSR easier.\n          safeSetContext(stripe);\n        }\n      });\n    } else if (parsed.tag === 'sync' && !ctx.stripe) {\n      // Or, handle a sync stripe instance going from null -> populated\n      safeSetContext(parsed.stripe);\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [parsed, ctx, options]); // Warn on changes to stripe prop\n\n  var prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn('Unsupported prop change on Elements: You cannot change the `stripe` prop after setting it.');\n    }\n  }, [prevStripe, rawStripeProp]); // Apply updates to elements when options prop has relevant changes\n\n  var prevOptions = usePrevious(options);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (!ctx.elements) {\n      return;\n    }\n\n    var updates = extractAllowedOptionsUpdates(options, prevOptions, ['clientSecret', 'fonts']);\n\n    if (updates) {\n      ctx.elements.update(updates);\n    }\n  }, [options, prevOptions, ctx.elements]); // Attach react-stripe-js version to stripe.js instance\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    registerWithStripeJs(ctx.stripe);\n  }, [ctx.stripe]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ElementsContext.Provider, {\n    value: ctx\n  }, children);\n};\nElements.propTypes = {\n  stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n  options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n};\nvar useElementsContextWithUseCase = function useElementsContextWithUseCase(useCaseMessage) {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n  return parseElementsContext(ctx, useCaseMessage);\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#useelements-hook\n */\n\nvar useElements = function useElements() {\n  var _useElementsContextWi = useElementsContextWithUseCase('calls useElements()'),\n      elements = _useElementsContextWi.elements;\n\n  return elements;\n};\n/**\n * @docs https://stripe.com/docs/stripe-js/react#elements-consumer\n */\n\nvar ElementsConsumer = function ElementsConsumer(_ref2) {\n  var children = _ref2.children;\n  var ctx = useElementsContextWithUseCase('mounts <ElementsConsumer>'); // Assert to satisfy the busted React.FC return type (it should be ReactNode)\n\n  return children(ctx);\n};\nElementsConsumer.propTypes = {\n  children: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired\n};\n\nvar _excluded$1 = [\"on\", \"session\"];\nvar CheckoutSdkContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutSdkContext.displayName = 'CheckoutSdkContext';\nvar parseCheckoutSdkContext = function parseCheckoutSdkContext(ctx, useCase) {\n  if (!ctx) {\n    throw new Error(\"Could not find CheckoutProvider context; You need to wrap the part of your app that \".concat(useCase, \" in an <CheckoutProvider> provider.\"));\n  }\n\n  return ctx;\n};\nvar CheckoutContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nCheckoutContext.displayName = 'CheckoutContext';\nvar extractCheckoutContextValue = function extractCheckoutContextValue(checkoutSdk, sessionState) {\n  if (!checkoutSdk) {\n    return null;\n  }\n\n  checkoutSdk.on;\n      checkoutSdk.session;\n      var actions = _objectWithoutProperties(checkoutSdk, _excluded$1);\n\n  if (!sessionState) {\n    return Object.assign(checkoutSdk.session(), actions);\n  }\n\n  return Object.assign(sessionState, actions);\n};\nvar INVALID_STRIPE_ERROR$1 = 'Invalid prop `stripe` supplied to `CheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.';\nvar CheckoutProvider = function CheckoutProvider(_ref) {\n  var rawStripeProp = _ref.stripe,\n      options = _ref.options,\n      children = _ref.children;\n  var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR$1);\n  }, [rawStripeProp]); // State used to trigger a re-render when sdk.session is updated\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      session = _React$useState2[0],\n      setSession = _React$useState2[1];\n\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState(function () {\n    return {\n      stripe: parsed.tag === 'sync' ? parsed.stripe : null,\n      checkoutSdk: null\n    };\n  }),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      ctx = _React$useState4[0],\n      setContext = _React$useState4[1];\n\n  var safeSetContext = function safeSetContext(stripe, checkoutSdk) {\n    setContext(function (ctx) {\n      if (ctx.stripe && ctx.checkoutSdk) {\n        return ctx;\n      }\n\n      return {\n        stripe: stripe,\n        checkoutSdk: checkoutSdk\n      };\n    });\n  }; // Ref used to avoid calling initCheckout multiple times when options changes\n\n\n  var initCheckoutCalledRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var isMounted = true;\n\n    if (parsed.tag === 'async' && !ctx.stripe) {\n      parsed.stripePromise.then(function (stripe) {\n        if (stripe && isMounted && !initCheckoutCalledRef.current) {\n          // Only update context if the component is still mounted\n          // and stripe is not null. We allow stripe to be null to make\n          // handling SSR easier.\n          initCheckoutCalledRef.current = true;\n          stripe.initCheckout(options).then(function (checkoutSdk) {\n            if (checkoutSdk) {\n              safeSetContext(stripe, checkoutSdk);\n              checkoutSdk.on('change', setSession);\n            }\n          });\n        }\n      });\n    } else if (parsed.tag === 'sync' && parsed.stripe && !initCheckoutCalledRef.current) {\n      initCheckoutCalledRef.current = true;\n      parsed.stripe.initCheckout(options).then(function (checkoutSdk) {\n        if (checkoutSdk) {\n          safeSetContext(parsed.stripe, checkoutSdk);\n          checkoutSdk.on('change', setSession);\n        }\n      });\n    }\n\n    return function () {\n      isMounted = false;\n    };\n  }, [parsed, ctx, options, setSession]); // Warn on changes to stripe prop\n\n  var prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn('Unsupported prop change on CheckoutProvider: You cannot change the `stripe` prop after setting it.');\n    }\n  }, [prevStripe, rawStripeProp]); // Apply updates to elements when options prop has relevant changes\n\n  var prevOptions = usePrevious(options);\n  var prevCheckoutSdk = usePrevious(ctx.checkoutSdk);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    var _prevOptions$elements, _options$elementsOpti;\n\n    // Ignore changes while checkout sdk is not initialized.\n    if (!ctx.checkoutSdk) {\n      return;\n    }\n\n    var previousAppearance = prevOptions === null || prevOptions === void 0 ? void 0 : (_prevOptions$elements = prevOptions.elementsOptions) === null || _prevOptions$elements === void 0 ? void 0 : _prevOptions$elements.appearance;\n    var currentAppearance = options === null || options === void 0 ? void 0 : (_options$elementsOpti = options.elementsOptions) === null || _options$elementsOpti === void 0 ? void 0 : _options$elementsOpti.appearance;\n    var hasAppearanceChanged = !isEqual(currentAppearance, previousAppearance);\n    var hasSdkLoaded = !prevCheckoutSdk && ctx.checkoutSdk;\n\n    if (currentAppearance && (hasAppearanceChanged || hasSdkLoaded)) {\n      ctx.checkoutSdk.changeAppearance(currentAppearance);\n    }\n  }, [options, prevOptions, ctx.checkoutSdk, prevCheckoutSdk]); // Attach react-stripe-js version to stripe.js instance\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    registerWithStripeJs(ctx.stripe);\n  }, [ctx.stripe]);\n  var checkoutContextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return extractCheckoutContextValue(ctx.checkoutSdk, session);\n  }, [ctx.checkoutSdk, session]);\n\n  if (!ctx.checkoutSdk) {\n    return null;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutSdkContext.Provider, {\n    value: ctx\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CheckoutContext.Provider, {\n    value: checkoutContextValue\n  }, children));\n};\nCheckoutProvider.propTypes = {\n  stripe: prop_types__WEBPACK_IMPORTED_MODULE_1__.any,\n  options: prop_types__WEBPACK_IMPORTED_MODULE_1__.shape({\n    fetchClientSecret: prop_types__WEBPACK_IMPORTED_MODULE_1__.func.isRequired,\n    elementsOptions: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n  }).isRequired\n};\nvar useCheckoutSdkContextWithUseCase = function useCheckoutSdkContextWithUseCase(useCaseString) {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n  return parseCheckoutSdkContext(ctx, useCaseString);\n};\nvar useElementsOrCheckoutSdkContextWithUseCase = function useElementsOrCheckoutSdkContextWithUseCase(useCaseString) {\n  var checkoutSdkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutSdkContext);\n  var elementsContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ElementsContext);\n\n  if (checkoutSdkContext && elementsContext) {\n    throw new Error(\"You cannot wrap the part of your app that \".concat(useCaseString, \" in both <CheckoutProvider> and <Elements> providers.\"));\n  }\n\n  if (checkoutSdkContext) {\n    return parseCheckoutSdkContext(checkoutSdkContext, useCaseString);\n  }\n\n  return parseElementsContext(elementsContext, useCaseString);\n};\nvar useCheckout = function useCheckout() {\n  // ensure it's in CheckoutProvider\n  useCheckoutSdkContextWithUseCase('calls useCheckout()');\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CheckoutContext);\n\n  if (!ctx) {\n    throw new Error('Could not find Checkout Context; You need to wrap the part of your app that calls useCheckout() in an <CheckoutProvider> provider.');\n  }\n\n  return ctx;\n};\n\nvar _excluded = [\"mode\"];\n\nvar capitalized = function capitalized(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nvar createElementComponent = function createElementComponent(type, isServer) {\n  var displayName = \"\".concat(capitalized(type), \"Element\");\n\n  var ClientElement = function ClientElement(_ref) {\n    var id = _ref.id,\n        className = _ref.className,\n        _ref$options = _ref.options,\n        options = _ref$options === void 0 ? {} : _ref$options,\n        onBlur = _ref.onBlur,\n        onFocus = _ref.onFocus,\n        onReady = _ref.onReady,\n        onChange = _ref.onChange,\n        onEscape = _ref.onEscape,\n        onClick = _ref.onClick,\n        onLoadError = _ref.onLoadError,\n        onLoaderStart = _ref.onLoaderStart,\n        onNetworksChange = _ref.onNetworksChange,\n        onConfirm = _ref.onConfirm,\n        onCancel = _ref.onCancel,\n        onShippingAddressChange = _ref.onShippingAddressChange,\n        onShippingRateChange = _ref.onShippingRateChange;\n    var ctx = useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n    var elements = 'elements' in ctx ? ctx.elements : null;\n    var checkoutSdk = 'checkoutSdk' in ctx ? ctx.checkoutSdk : null;\n\n    var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(null),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        element = _React$useState2[0],\n        setElement = _React$useState2[1];\n\n    var elementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // For every event where the merchant provides a callback, call element.on\n    // with that callback. If the merchant ever changes the callback, removes\n    // the old callback with element.off and then call element.on with the new one.\n\n    useAttachEvent(element, 'blur', onBlur);\n    useAttachEvent(element, 'focus', onFocus);\n    useAttachEvent(element, 'escape', onEscape);\n    useAttachEvent(element, 'click', onClick);\n    useAttachEvent(element, 'loaderror', onLoadError);\n    useAttachEvent(element, 'loaderstart', onLoaderStart);\n    useAttachEvent(element, 'networkschange', onNetworksChange);\n    useAttachEvent(element, 'confirm', onConfirm);\n    useAttachEvent(element, 'cancel', onCancel);\n    useAttachEvent(element, 'shippingaddresschange', onShippingAddressChange);\n    useAttachEvent(element, 'shippingratechange', onShippingRateChange);\n    useAttachEvent(element, 'change', onChange);\n    var readyCallback;\n\n    if (onReady) {\n      if (type === 'expressCheckout') {\n        // Passes through the event, which includes visible PM types\n        readyCallback = onReady;\n      } else {\n        // For other Elements, pass through the Element itself.\n        readyCallback = function readyCallback() {\n          onReady(element);\n        };\n      }\n    }\n\n    useAttachEvent(element, 'ready', readyCallback);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      if (elementRef.current === null && domNode.current !== null && (elements || checkoutSdk)) {\n        var newElement = null;\n\n        if (checkoutSdk) {\n          switch (type) {\n            case 'payment':\n              newElement = checkoutSdk.createPaymentElement(options);\n              break;\n\n            case 'address':\n              if ('mode' in options) {\n                var mode = options.mode,\n                    restOptions = _objectWithoutProperties(options, _excluded);\n\n                if (mode === 'shipping') {\n                  newElement = checkoutSdk.createShippingAddressElement(restOptions);\n                } else if (mode === 'billing') {\n                  newElement = checkoutSdk.createBillingAddressElement(restOptions);\n                } else {\n                  throw new Error(\"Invalid options.mode. mode must be 'billing' or 'shipping'.\");\n                }\n              } else {\n                throw new Error(\"You must supply options.mode. mode must be 'billing' or 'shipping'.\");\n              }\n\n              break;\n\n            case 'expressCheckout':\n              newElement = checkoutSdk.createExpressCheckoutElement(options);\n              break;\n\n            case 'currencySelector':\n              newElement = checkoutSdk.createCurrencySelectorElement();\n              break;\n\n            default:\n              throw new Error(\"Invalid Element type \".concat(displayName, \". You must use either the <PaymentElement />, <AddressElement options={{mode: 'shipping'}} />, <AddressElement options={{mode: 'billing'}} />, or <ExpressCheckoutElement />.\"));\n          }\n        } else if (elements) {\n          newElement = elements.create(type, options);\n        } // Store element in a ref to ensure it's _immediately_ available in cleanup hooks in StrictMode\n\n\n        elementRef.current = newElement; // Store element in state to facilitate event listener attachment\n\n        setElement(newElement);\n\n        if (newElement) {\n          newElement.mount(domNode.current);\n        }\n      }\n    }, [elements, checkoutSdk, options]);\n    var prevOptions = usePrevious(options);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n      if (!elementRef.current) {\n        return;\n      }\n\n      var updates = extractAllowedOptionsUpdates(options, prevOptions, ['paymentRequest']);\n\n      if (updates && 'update' in elementRef.current) {\n        elementRef.current.update(updates);\n      }\n    }, [options, prevOptions]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n      return function () {\n        if (elementRef.current && typeof elementRef.current.destroy === 'function') {\n          try {\n            elementRef.current.destroy();\n            elementRef.current = null;\n          } catch (error) {// Do nothing\n          }\n        }\n      };\n    }, []);\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      id: id,\n      className: className,\n      ref: domNode\n    });\n  }; // Only render the Element wrapper in a server environment.\n\n\n  var ServerElement = function ServerElement(props) {\n    useElementsOrCheckoutSdkContextWithUseCase(\"mounts <\".concat(displayName, \">\"));\n    var id = props.id,\n        className = props.className;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      id: id,\n      className: className\n    });\n  };\n\n  var Element = isServer ? ServerElement : ClientElement;\n  Element.propTypes = {\n    id: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n    className: prop_types__WEBPACK_IMPORTED_MODULE_1__.string,\n    onChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onBlur: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onFocus: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onReady: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onEscape: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onClick: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onLoadError: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onLoaderStart: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onNetworksChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onConfirm: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onCancel: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onShippingAddressChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    onShippingRateChange: prop_types__WEBPACK_IMPORTED_MODULE_1__.func,\n    options: prop_types__WEBPACK_IMPORTED_MODULE_1__.object\n  };\n  Element.displayName = displayName;\n  Element.__elementType = type;\n  return Element;\n};\n\nvar isServer = typeof window === 'undefined';\n\nvar EmbeddedCheckoutContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nEmbeddedCheckoutContext.displayName = 'EmbeddedCheckoutProviderContext';\nvar useEmbeddedCheckoutContext = function useEmbeddedCheckoutContext() {\n  var ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EmbeddedCheckoutContext);\n\n  if (!ctx) {\n    throw new Error('<EmbeddedCheckout> must be used within <EmbeddedCheckoutProvider>');\n  }\n\n  return ctx;\n};\nvar INVALID_STRIPE_ERROR = 'Invalid prop `stripe` supplied to `EmbeddedCheckoutProvider`. We recommend using the `loadStripe` utility from `@stripe/stripe-js`. See https://stripe.com/docs/stripe-js/react#elements-props-stripe for details.';\nvar EmbeddedCheckoutProvider = function EmbeddedCheckoutProvider(_ref) {\n  var rawStripeProp = _ref.stripe,\n      options = _ref.options,\n      children = _ref.children;\n  var parsed = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(function () {\n    return parseStripeProp(rawStripeProp, INVALID_STRIPE_ERROR);\n  }, [rawStripeProp]);\n  var embeddedCheckoutPromise = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  var loadedStripe = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    embeddedCheckout: null\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      ctx = _React$useState2[0],\n      setContext = _React$useState2[1];\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    // Don't support any ctx updates once embeddedCheckout or stripe is set.\n    if (loadedStripe.current || embeddedCheckoutPromise.current) {\n      return;\n    }\n\n    var setStripeAndInitEmbeddedCheckout = function setStripeAndInitEmbeddedCheckout(stripe) {\n      if (loadedStripe.current || embeddedCheckoutPromise.current) return;\n      loadedStripe.current = stripe;\n      embeddedCheckoutPromise.current = loadedStripe.current.initEmbeddedCheckout(options).then(function (embeddedCheckout) {\n        setContext({\n          embeddedCheckout: embeddedCheckout\n        });\n      });\n    }; // For an async stripePromise, store it once resolved\n\n\n    if (parsed.tag === 'async' && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n      parsed.stripePromise.then(function (stripe) {\n        if (stripe) {\n          setStripeAndInitEmbeddedCheckout(stripe);\n        }\n      });\n    } else if (parsed.tag === 'sync' && !loadedStripe.current && (options.clientSecret || options.fetchClientSecret)) {\n      // Or, handle a sync stripe instance going from null -> populated\n      setStripeAndInitEmbeddedCheckout(parsed.stripe);\n    }\n  }, [parsed, options, ctx, loadedStripe]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    // cleanup on unmount\n    return function () {\n      // If embedded checkout is fully initialized, destroy it.\n      if (ctx.embeddedCheckout) {\n        embeddedCheckoutPromise.current = null;\n        ctx.embeddedCheckout.destroy();\n      } else if (embeddedCheckoutPromise.current) {\n        // If embedded checkout is still initializing, destroy it once\n        // it's done. This could be caused by unmounting very quickly\n        // after mounting.\n        embeddedCheckoutPromise.current.then(function () {\n          embeddedCheckoutPromise.current = null;\n\n          if (ctx.embeddedCheckout) {\n            ctx.embeddedCheckout.destroy();\n          }\n        });\n      }\n    };\n  }, [ctx.embeddedCheckout]); // Attach react-stripe-js version to stripe.js instance\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    registerWithStripeJs(loadedStripe);\n  }, [loadedStripe]); // Warn on changes to stripe prop.\n  // The stripe prop value can only go from null to non-null once and\n  // can't be changed after that.\n\n  var prevStripe = usePrevious(rawStripeProp);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevStripe !== null && prevStripe !== rawStripeProp) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the `stripe` prop after setting it.');\n    }\n  }, [prevStripe, rawStripeProp]); // Warn on changes to options.\n\n  var prevOptions = usePrevious(options);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    if (prevOptions == null) {\n      return;\n    }\n\n    if (options == null) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot unset options after setting them.');\n      return;\n    }\n\n    if (options.clientSecret === undefined && options.fetchClientSecret === undefined) {\n      console.warn('Invalid props passed to EmbeddedCheckoutProvider: You must provide one of either `options.fetchClientSecret` or `options.clientSecret`.');\n    }\n\n    if (prevOptions.clientSecret != null && options.clientSecret !== prevOptions.clientSecret) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the client secret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.');\n    }\n\n    if (prevOptions.fetchClientSecret != null && options.fetchClientSecret !== prevOptions.fetchClientSecret) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change fetchClientSecret after setting it. Unmount and create a new instance of EmbeddedCheckoutProvider instead.');\n    }\n\n    if (prevOptions.onComplete != null && options.onComplete !== prevOptions.onComplete) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onComplete option after setting it.');\n    }\n\n    if (prevOptions.onShippingDetailsChange != null && options.onShippingDetailsChange !== prevOptions.onShippingDetailsChange) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onShippingDetailsChange option after setting it.');\n    }\n\n    if (prevOptions.onLineItemsChange != null && options.onLineItemsChange !== prevOptions.onLineItemsChange) {\n      console.warn('Unsupported prop change on EmbeddedCheckoutProvider: You cannot change the onLineItemsChange option after setting it.');\n    }\n  }, [prevOptions, options]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmbeddedCheckoutContext.Provider, {\n    value: ctx\n  }, children);\n};\n\nvar EmbeddedCheckoutClientElement = function EmbeddedCheckoutClientElement(_ref) {\n  var id = _ref.id,\n      className = _ref.className;\n\n  var _useEmbeddedCheckoutC = useEmbeddedCheckoutContext(),\n      embeddedCheckout = _useEmbeddedCheckoutC.embeddedCheckout;\n\n  var isMounted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  var domNode = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(function () {\n    if (!isMounted.current && embeddedCheckout && domNode.current !== null) {\n      embeddedCheckout.mount(domNode.current);\n      isMounted.current = true;\n    } // Clean up on unmount\n\n\n    return function () {\n      if (isMounted.current && embeddedCheckout) {\n        try {\n          embeddedCheckout.unmount();\n          isMounted.current = false;\n        } catch (e) {// Do nothing.\n          // Parent effects are destroyed before child effects, so\n          // in cases where both the EmbeddedCheckoutProvider and\n          // the EmbeddedCheckout component are removed at the same\n          // time, the embeddedCheckout instance will be destroyed,\n          // which causes an error when calling unmount.\n        }\n      }\n    };\n  }, [embeddedCheckout]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    ref: domNode,\n    id: id,\n    className: className\n  });\n}; // Only render the wrapper in a server environment.\n\n\nvar EmbeddedCheckoutServerElement = function EmbeddedCheckoutServerElement(_ref2) {\n  var id = _ref2.id,\n      className = _ref2.className;\n  // Validate that we are in the right context by calling useEmbeddedCheckoutContext.\n  useEmbeddedCheckoutContext();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    id: id,\n    className: className\n  });\n};\n\nvar EmbeddedCheckout = isServer ? EmbeddedCheckoutServerElement : EmbeddedCheckoutClientElement;\n\n/**\n * @docs https://stripe.com/docs/stripe-js/react#usestripe-hook\n */\n\nvar useStripe = function useStripe() {\n  var _useElementsOrCheckou = useElementsOrCheckoutSdkContextWithUseCase('calls useStripe()'),\n      stripe = _useElementsOrCheckou.stripe;\n\n  return stripe;\n};\n\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AuBankAccountElement = createElementComponent('auBankAccount', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardElement = createElementComponent('card', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardNumberElement = createElementComponent('cardNumber', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardExpiryElement = createElementComponent('cardExpiry', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar CardCvcElement = createElementComponent('cardCvc', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar FpxBankElement = createElementComponent('fpxBank', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar IbanElement = createElementComponent('iban', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar IdealBankElement = createElementComponent('idealBank', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar P24BankElement = createElementComponent('p24Bank', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar EpsBankElement = createElementComponent('epsBank', isServer);\nvar PaymentElement = createElementComponent('payment', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar ExpressCheckoutElement = createElementComponent('expressCheckout', isServer);\n/**\n * Requires beta access:\n * Contact [Stripe support](https://support.stripe.com/) for more information.\n */\n\nvar CurrencySelectorElement = createElementComponent('currencySelector', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar PaymentRequestButtonElement = createElementComponent('paymentRequestButton', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar LinkAuthenticationElement = createElementComponent('linkAuthentication', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AddressElement = createElementComponent('address', isServer);\n/**\n * @deprecated\n * Use `AddressElement` instead.\n *\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar ShippingAddressElement = createElementComponent('shippingAddress', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar PaymentMethodMessagingElement = createElementComponent('paymentMethodMessaging', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AffirmMessageElement = createElementComponent('affirmMessage', isServer);\n/**\n * @docs https://stripe.com/docs/stripe-js/react#element-components\n */\n\nvar AfterpayClearpayMessageElement = createElementComponent('afterpayClearpayMessage', isServer);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDUzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXVpQiIsInNvdXJjZXMiOlsid2VicGFjazovL2dydXBvdmlzaW9uYXJpb3MvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9yZWFjdC1zdHJpcGUtanMvZGlzdC9yZWFjdC1zdHJpcGUuZXNtLm1qcz85MTliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdXNlQXR0YWNoRXZlbnQgPSBmdW5jdGlvbiB1c2VBdHRhY2hFdmVudChlbGVtZW50LCBldmVudCwgY2IpIHtcbiAgdmFyIGNiRGVmaW5lZCA9ICEhY2I7XG4gIHZhciBjYlJlZiA9IFJlYWN0LnVzZVJlZihjYik7IC8vIEluIG1hbnkgaW50ZWdyYXRpb25zIHRoZSBjYWxsYmFjayBwcm9wIGNoYW5nZXMgb24gZWFjaCByZW5kZXIuXG4gIC8vIFVzaW5nIGEgcmVmIHNhdmVzIHVzIGZyb20gY2FsbGluZyBlbGVtZW50Lm9uLy5vZmYgZXZlcnkgcmVuZGVyLlxuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgY2JSZWYuY3VycmVudCA9IGNiO1xuICB9LCBbY2JdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNiRGVmaW5lZCB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIHZhciBkZWNvcmF0ZWRDYiA9IGZ1bmN0aW9uIGRlY29yYXRlZENiKCkge1xuICAgICAgaWYgKGNiUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2JSZWYuY3VycmVudC5hcHBseShjYlJlZiwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlbWVudC5vbihldmVudCwgZGVjb3JhdGVkQ2IpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBlbGVtZW50Lm9mZihldmVudCwgZGVjb3JhdGVkQ2IpO1xuICAgIH07XG4gIH0sIFtjYkRlZmluZWQsIGV2ZW50LCBlbGVtZW50LCBjYlJlZl0pO1xufTtcblxudmFyIHVzZVByZXZpb3VzID0gZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgdmFyIHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn07XG5cbnZhciBpc1Vua25vd25PYmplY3QgPSBmdW5jdGlvbiBpc1Vua25vd25PYmplY3QocmF3KSB7XG4gIHJldHVybiByYXcgIT09IG51bGwgJiYgX3R5cGVvZihyYXcpID09PSAnb2JqZWN0Jztcbn07XG52YXIgaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlKHJhdykge1xuICByZXR1cm4gaXNVbmtub3duT2JqZWN0KHJhdykgJiYgdHlwZW9mIHJhdy50aGVuID09PSAnZnVuY3Rpb24nO1xufTsgLy8gV2UgYXJlIHVzaW5nIHR5cGVzIHRvIGVuZm9yY2UgdGhlIGBzdHJpcGVgIHByb3AgaW4gdGhpcyBsaWIsXG4vLyBidXQgaW4gYW4gdW50eXBlZCBpbnRlZ3JhdGlvbiBgc3RyaXBlYCBjb3VsZCBiZSBhbnl0aGluZywgc28gd2UgbmVlZFxuLy8gdG8gZG8gc29tZSBzYW5pdHkgdmFsaWRhdGlvbiB0byBwcmV2ZW50IHR5cGUgZXJyb3JzLlxuXG52YXIgaXNTdHJpcGUgPSBmdW5jdGlvbiBpc1N0cmlwZShyYXcpIHtcbiAgcmV0dXJuIGlzVW5rbm93bk9iamVjdChyYXcpICYmIHR5cGVvZiByYXcuZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jcmVhdGVUb2tlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmF3LmNyZWF0ZVBheW1lbnRNZXRob2QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJhdy5jb25maXJtQ2FyZFBheW1lbnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgUExBSU5fT0JKRUNUX1NUUiA9ICdbb2JqZWN0IE9iamVjdF0nO1xudmFyIGlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSB7XG4gIGlmICghaXNVbmtub3duT2JqZWN0KGxlZnQpIHx8ICFpc1Vua25vd25PYmplY3QocmlnaHQpKSB7XG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICB9XG5cbiAgdmFyIGxlZnRBcnJheSA9IEFycmF5LmlzQXJyYXkobGVmdCk7XG4gIHZhciByaWdodEFycmF5ID0gQXJyYXkuaXNBcnJheShyaWdodCk7XG4gIGlmIChsZWZ0QXJyYXkgIT09IHJpZ2h0QXJyYXkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGxlZnRQbGFpbk9iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChsZWZ0KSA9PT0gUExBSU5fT0JKRUNUX1NUUjtcbiAgdmFyIHJpZ2h0UGxhaW5PYmplY3QgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmlnaHQpID09PSBQTEFJTl9PQkpFQ1RfU1RSO1xuICBpZiAobGVmdFBsYWluT2JqZWN0ICE9PSByaWdodFBsYWluT2JqZWN0KSByZXR1cm4gZmFsc2U7IC8vIG5vdCBzdXJlIHdoYXQgc29ydCBvZiBzcGVjaWFsIG9iamVjdCB0aGlzIGlzIChyZWdleHAgaXMgb25lIG9wdGlvbiksIHNvXG4gIC8vIGZhbGxiYWNrIHRvIHJlZmVyZW5jZSBjaGVjay5cblxuICBpZiAoIWxlZnRQbGFpbk9iamVjdCAmJiAhbGVmdEFycmF5KSByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gIHZhciBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnQpO1xuICB2YXIgcmlnaHRLZXlzID0gT2JqZWN0LmtleXMocmlnaHQpO1xuICBpZiAobGVmdEtleXMubGVuZ3RoICE9PSByaWdodEtleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrZXlTZXQgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAga2V5U2V0W2xlZnRLZXlzW2ldXSA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcmlnaHRLZXlzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgIGtleVNldFtyaWdodEtleXNbX2ldXSA9IHRydWU7XG4gIH1cblxuICB2YXIgYWxsS2V5cyA9IE9iamVjdC5rZXlzKGtleVNldCk7XG5cbiAgaWYgKGFsbEtleXMubGVuZ3RoICE9PSBsZWZ0S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbCA9IGxlZnQ7XG4gIHZhciByID0gcmlnaHQ7XG5cbiAgdmFyIHByZWQgPSBmdW5jdGlvbiBwcmVkKGtleSkge1xuICAgIHJldHVybiBpc0VxdWFsKGxba2V5XSwgcltrZXldKTtcbiAgfTtcblxuICByZXR1cm4gYWxsS2V5cy5ldmVyeShwcmVkKTtcbn07XG5cbnZhciBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzID0gZnVuY3Rpb24gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgaW1tdXRhYmxlS2V5cykge1xuICBpZiAoIWlzVW5rbm93bk9iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAobmV3T3B0aW9ucywga2V5KSB7XG4gICAgdmFyIGlzVXBkYXRlZCA9ICFpc1Vua25vd25PYmplY3QocHJldk9wdGlvbnMpIHx8ICFpc0VxdWFsKG9wdGlvbnNba2V5XSwgcHJldk9wdGlvbnNba2V5XSk7XG5cbiAgICBpZiAoaW1tdXRhYmxlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBpZiAoaXNVcGRhdGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIHByb3AgY2hhbmdlOiBvcHRpb25zLlwiLmNvbmNhdChrZXksIFwiIGlzIG5vdCBhIG11dGFibGUgcHJvcGVydHkuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFpc1VwZGF0ZWQpIHtcbiAgICAgIHJldHVybiBuZXdPcHRpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbmV3T3B0aW9ucyB8fCB7fSksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgb3B0aW9uc1trZXldKSk7XG4gIH0sIG51bGwpO1xufTtcblxudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SJDIgPSAnSW52YWxpZCBwcm9wIGBzdHJpcGVgIHN1cHBsaWVkIHRvIGBFbGVtZW50c2AuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nOyAvLyBXZSBhcmUgdXNpbmcgdHlwZXMgdG8gZW5mb3JjZSB0aGUgYHN0cmlwZWAgcHJvcCBpbiB0aGlzIGxpYiwgYnV0IGluIGEgcmVhbFxuLy8gaW50ZWdyYXRpb24gYHN0cmlwZWAgY291bGQgYmUgYW55dGhpbmcsIHNvIHdlIG5lZWQgdG8gZG8gc29tZSBzYW5pdHlcbi8vIHZhbGlkYXRpb24gdG8gcHJldmVudCB0eXBlIGVycm9ycy5cblxudmFyIHZhbGlkYXRlU3RyaXBlID0gZnVuY3Rpb24gdmFsaWRhdGVTdHJpcGUobWF5YmVTdHJpcGUpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUiQyO1xuXG4gIGlmIChtYXliZVN0cmlwZSA9PT0gbnVsbCB8fCBpc1N0cmlwZShtYXliZVN0cmlwZSkpIHtcbiAgICByZXR1cm4gbWF5YmVTdHJpcGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xufTtcblxudmFyIHBhcnNlU3RyaXBlUHJvcCA9IGZ1bmN0aW9uIHBhcnNlU3RyaXBlUHJvcChyYXcpIHtcbiAgdmFyIGVycm9yTXNnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBJTlZBTElEX1NUUklQRV9FUlJPUiQyO1xuXG4gIGlmIChpc1Byb21pc2UocmF3KSkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6ICdhc3luYycsXG4gICAgICBzdHJpcGVQcm9taXNlOiBQcm9taXNlLnJlc29sdmUocmF3KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3RyaXBlKHJlc3VsdCwgZXJyb3JNc2cpO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IHZhbGlkYXRlU3RyaXBlKHJhdywgZXJyb3JNc2cpO1xuXG4gIGlmIChzdHJpcGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAnZW1wdHknXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGFnOiAnc3luYycsXG4gICAgc3RyaXBlOiBzdHJpcGVcbiAgfTtcbn07XG5cbnZhciByZWdpc3RlcldpdGhTdHJpcGVKcyA9IGZ1bmN0aW9uIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKHN0cmlwZSkge1xuICBpZiAoIXN0cmlwZSB8fCAhc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIgfHwgIXN0cmlwZS5yZWdpc3RlckFwcEluZm8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHJpcGUuX3JlZ2lzdGVyV3JhcHBlcih7XG4gICAgbmFtZTogJ3JlYWN0LXN0cmlwZS1qcycsXG4gICAgdmVyc2lvbjogXCIzLjcuMFwiXG4gIH0pO1xuXG4gIHN0cmlwZS5yZWdpc3RlckFwcEluZm8oe1xuICAgIG5hbWU6ICdyZWFjdC1zdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiMy43LjBcIixcbiAgICB1cmw6ICdodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QnXG4gIH0pO1xufTtcblxudmFyIEVsZW1lbnRzQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuRWxlbWVudHNDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VsZW1lbnRzQ29udGV4dCc7XG52YXIgcGFyc2VFbGVtZW50c0NvbnRleHQgPSBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzQ29udGV4dChjdHgsIHVzZUNhc2UpIHtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBFbGVtZW50cyBjb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgXCIuY29uY2F0KHVzZUNhc2UsIFwiIGluIGFuIDxFbGVtZW50cz4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xuLyoqXG4gKiBUaGUgYEVsZW1lbnRzYCBwcm92aWRlciBhbGxvd3MgeW91IHRvIHVzZSBbRWxlbWVudCBjb21wb25lbnRzXShodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzKSBhbmQgYWNjZXNzIHRoZSBbU3RyaXBlIG9iamVjdF0oaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3MvanMvaW5pdGlhbGl6aW5nKSBpbiBhbnkgbmVzdGVkIGNvbXBvbmVudC5cbiAqIFJlbmRlciBhbiBgRWxlbWVudHNgIHByb3ZpZGVyIGF0IHRoZSByb290IG9mIHlvdXIgUmVhY3QgYXBwIHNvIHRoYXQgaXQgaXMgYXZhaWxhYmxlIGV2ZXJ5d2hlcmUgeW91IG5lZWQgaXQuXG4gKlxuICogVG8gdXNlIHRoZSBgRWxlbWVudHNgIHByb3ZpZGVyLCBjYWxsIGBsb2FkU3RyaXBlYCBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2Agd2l0aCB5b3VyIHB1Ymxpc2hhYmxlIGtleS5cbiAqIFRoZSBgbG9hZFN0cmlwZWAgZnVuY3Rpb24gd2lsbCBhc3luY2hyb25vdXNseSBsb2FkIHRoZSBTdHJpcGUuanMgc2NyaXB0IGFuZCBpbml0aWFsaXplIGEgYFN0cmlwZWAgb2JqZWN0LlxuICogUGFzcyB0aGUgcmV0dXJuZWQgYFByb21pc2VgIHRvIGBFbGVtZW50c2AuXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3ZpZGVyXG4gKi9cblxudmFyIEVsZW1lbnRzID0gZnVuY3Rpb24gRWxlbWVudHMoX3JlZikge1xuICB2YXIgcmF3U3RyaXBlUHJvcCA9IF9yZWYuc3RyaXBlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgdmFyIHBhcnNlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZVN0cmlwZVByb3AocmF3U3RyaXBlUHJvcCk7XG4gIH0sIFtyYXdTdHJpcGVQcm9wXSk7IC8vIEZvciBhIHN5bmMgc3RyaXBlIGluc3RhbmNlLCBpbml0aWFsaXplIGludG8gY29udGV4dFxuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmlwZTogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZSA6IG51bGwsXG4gICAgICBlbGVtZW50czogcGFyc2VkLnRhZyA9PT0gJ3N5bmMnID8gcGFyc2VkLnN0cmlwZS5lbGVtZW50cyhvcHRpb25zKSA6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW91bnRlZCA9IHRydWU7XG5cbiAgICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUpIHtcbiAgICAgIHNldENvbnRleHQoZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAvLyBuby1vcCBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdHJpcGUgaW5zdGFuY2UgKGh0dHBzOi8vZ2l0aHViLmNvbS9zdHJpcGUvcmVhY3Qtc3RyaXBlLWpzL2lzc3Vlcy8yOTYpXG4gICAgICAgIGlmIChjdHguc3RyaXBlKSByZXR1cm4gY3R4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0cmlwZTogc3RyaXBlLFxuICAgICAgICAgIGVsZW1lbnRzOiBzdHJpcGUuZWxlbWVudHMob3B0aW9ucylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07IC8vIEZvciBhbiBhc3luYyBzdHJpcGVQcm9taXNlLCBzdG9yZSBpdCBpbiBjb250ZXh0IG9uY2UgcmVzb2x2ZWRcblxuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIEVsZW1lbnRzIGNvbnRleHQgaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkXG4gICAgICAgICAgLy8gYW5kIHN0cmlwZSBpcyBub3QgbnVsbC4gV2UgYWxsb3cgc3RyaXBlIHRvIGJlIG51bGwgdG8gbWFrZVxuICAgICAgICAgIC8vIGhhbmRsaW5nIFNTUiBlYXNpZXIuXG4gICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzYWZlU2V0Q29udGV4dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW3BhcnNlZCwgY3R4LCBvcHRpb25zXSk7IC8vIFdhcm4gb24gY2hhbmdlcyB0byBzdHJpcGUgcHJvcFxuXG4gIHZhciBwcmV2U3RyaXBlID0gdXNlUHJldmlvdXMocmF3U3RyaXBlUHJvcCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZTdHJpcGUgIT09IG51bGwgJiYgcHJldlN0cmlwZSAhPT0gcmF3U3RyaXBlUHJvcCkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbGVtZW50czogWW91IGNhbm5vdCBjaGFuZ2UgdGhlIGBzdHJpcGVgIHByb3AgYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2U3RyaXBlLCByYXdTdHJpcGVQcm9wXSk7IC8vIEFwcGx5IHVwZGF0ZXMgdG8gZWxlbWVudHMgd2hlbiBvcHRpb25zIHByb3AgaGFzIHJlbGV2YW50IGNoYW5nZXNcblxuICB2YXIgcHJldk9wdGlvbnMgPSB1c2VQcmV2aW91cyhvcHRpb25zKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWN0eC5lbGVtZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVzID0gZXh0cmFjdEFsbG93ZWRPcHRpb25zVXBkYXRlcyhvcHRpb25zLCBwcmV2T3B0aW9ucywgWydjbGllbnRTZWNyZXQnLCAnZm9udHMnXSk7XG5cbiAgICBpZiAodXBkYXRlcykge1xuICAgICAgY3R4LmVsZW1lbnRzLnVwZGF0ZSh1cGRhdGVzKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBwcmV2T3B0aW9ucywgY3R4LmVsZW1lbnRzXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRWxlbWVudHNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGN0eFxuICB9LCBjaGlsZHJlbik7XG59O1xuRWxlbWVudHMucHJvcFR5cGVzID0ge1xuICBzdHJpcGU6IFByb3BUeXBlcy5hbnksXG4gIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3Rcbn07XG52YXIgdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UgPSBmdW5jdGlvbiB1c2VFbGVtZW50c0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlTWVzc2FnZSkge1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChFbGVtZW50c0NvbnRleHQpO1xuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoY3R4LCB1c2VDYXNlTWVzc2FnZSk7XG59O1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjdXNlZWxlbWVudHMtaG9va1xuICovXG5cbnZhciB1c2VFbGVtZW50cyA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzKCkge1xuICB2YXIgX3VzZUVsZW1lbnRzQ29udGV4dFdpID0gdXNlRWxlbWVudHNDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZUVsZW1lbnRzKCknKSxcbiAgICAgIGVsZW1lbnRzID0gX3VzZUVsZW1lbnRzQ29udGV4dFdpLmVsZW1lbnRzO1xuXG4gIHJldHVybiBlbGVtZW50cztcbn07XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50cy1jb25zdW1lclxuICovXG5cbnZhciBFbGVtZW50c0NvbnN1bWVyID0gZnVuY3Rpb24gRWxlbWVudHNDb25zdW1lcihfcmVmMikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbjtcbiAgdmFyIGN0eCA9IHVzZUVsZW1lbnRzQ29udGV4dFdpdGhVc2VDYXNlKCdtb3VudHMgPEVsZW1lbnRzQ29uc3VtZXI+Jyk7IC8vIEFzc2VydCB0byBzYXRpc2Z5IHRoZSBidXN0ZWQgUmVhY3QuRkMgcmV0dXJuIHR5cGUgKGl0IHNob3VsZCBiZSBSZWFjdE5vZGUpXG5cbiAgcmV0dXJuIGNoaWxkcmVuKGN0eCk7XG59O1xuRWxlbWVudHNDb25zdW1lci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJvblwiLCBcInNlc3Npb25cIl07XG52YXIgQ2hlY2tvdXRTZGtDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5DaGVja291dFNka0NvbnRleHQuZGlzcGxheU5hbWUgPSAnQ2hlY2tvdXRTZGtDb250ZXh0JztcbnZhciBwYXJzZUNoZWNrb3V0U2RrQ29udGV4dCA9IGZ1bmN0aW9uIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0KGN0eCwgdXNlQ2FzZSkge1xuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIENoZWNrb3V0UHJvdmlkZXIgY29udGV4dDsgWW91IG5lZWQgdG8gd3JhcCB0aGUgcGFydCBvZiB5b3VyIGFwcCB0aGF0IFwiLmNvbmNhdCh1c2VDYXNlLCBcIiBpbiBhbiA8Q2hlY2tvdXRQcm92aWRlcj4gcHJvdmlkZXIuXCIpKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIENoZWNrb3V0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuQ2hlY2tvdXRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0NoZWNrb3V0Q29udGV4dCc7XG52YXIgZXh0cmFjdENoZWNrb3V0Q29udGV4dFZhbHVlID0gZnVuY3Rpb24gZXh0cmFjdENoZWNrb3V0Q29udGV4dFZhbHVlKGNoZWNrb3V0U2RrLCBzZXNzaW9uU3RhdGUpIHtcbiAgaWYgKCFjaGVja291dFNkaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2hlY2tvdXRTZGsub247XG4gICAgICBjaGVja291dFNkay5zZXNzaW9uO1xuICAgICAgdmFyIGFjdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoY2hlY2tvdXRTZGssIF9leGNsdWRlZCQxKTtcblxuICBpZiAoIXNlc3Npb25TdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNoZWNrb3V0U2RrLnNlc3Npb24oKSwgYWN0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihzZXNzaW9uU3RhdGUsIGFjdGlvbnMpO1xufTtcbnZhciBJTlZBTElEX1NUUklQRV9FUlJPUiQxID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgQ2hlY2tvdXRQcm92aWRlcmAuIFdlIHJlY29tbWVuZCB1c2luZyB0aGUgYGxvYWRTdHJpcGVgIHV0aWxpdHkgZnJvbSBgQHN0cmlwZS9zdHJpcGUtanNgLiBTZWUgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnRzLXByb3BzLXN0cmlwZSBmb3IgZGV0YWlscy4nO1xudmFyIENoZWNrb3V0UHJvdmlkZXIgPSBmdW5jdGlvbiBDaGVja291dFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3AsIElOVkFMSURfU1RSSVBFX0VSUk9SJDEpO1xuICB9LCBbcmF3U3RyaXBlUHJvcF0pOyAvLyBTdGF0ZSB1c2VkIHRvIHRyaWdnZXIgYSByZS1yZW5kZXIgd2hlbiBzZGsuc2Vzc2lvbiBpcyB1cGRhdGVkXG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgX1JlYWN0JHVzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF9SZWFjdCR1c2VTdGF0ZSwgMiksXG4gICAgICBzZXNzaW9uID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldFNlc3Npb24gPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpcGU6IHBhcnNlZC50YWcgPT09ICdzeW5jJyA/IHBhcnNlZC5zdHJpcGUgOiBudWxsLFxuICAgICAgY2hlY2tvdXRTZGs6IG51bGxcbiAgICB9O1xuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICAgIGN0eCA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRDb250ZXh0ID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICB2YXIgc2FmZVNldENvbnRleHQgPSBmdW5jdGlvbiBzYWZlU2V0Q29udGV4dChzdHJpcGUsIGNoZWNrb3V0U2RrKSB7XG4gICAgc2V0Q29udGV4dChmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAoY3R4LnN0cmlwZSAmJiBjdHguY2hlY2tvdXRTZGspIHtcbiAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaXBlOiBzdHJpcGUsXG4gICAgICAgIGNoZWNrb3V0U2RrOiBjaGVja291dFNka1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTsgLy8gUmVmIHVzZWQgdG8gYXZvaWQgY2FsbGluZyBpbml0Q2hlY2tvdXQgbXVsdGlwbGUgdGltZXMgd2hlbiBvcHRpb25zIGNoYW5nZXNcblxuXG4gIHZhciBpbml0Q2hlY2tvdXRDYWxsZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHBhcnNlZC50YWcgPT09ICdhc3luYycgJiYgIWN0eC5zdHJpcGUpIHtcbiAgICAgIHBhcnNlZC5zdHJpcGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHN0cmlwZSkge1xuICAgICAgICBpZiAoc3RyaXBlICYmIGlzTW91bnRlZCAmJiAhaW5pdENoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBjb250ZXh0IGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZFxuICAgICAgICAgIC8vIGFuZCBzdHJpcGUgaXMgbm90IG51bGwuIFdlIGFsbG93IHN0cmlwZSB0byBiZSBudWxsIHRvIG1ha2VcbiAgICAgICAgICAvLyBoYW5kbGluZyBTU1IgZWFzaWVyLlxuICAgICAgICAgIGluaXRDaGVja291dENhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBzdHJpcGUuaW5pdENoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tvdXRTZGspIHtcbiAgICAgICAgICAgICAgc2FmZVNldENvbnRleHQoc3RyaXBlLCBjaGVja291dFNkayk7XG4gICAgICAgICAgICAgIGNoZWNrb3V0U2RrLm9uKCdjaGFuZ2UnLCBzZXRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWQudGFnID09PSAnc3luYycgJiYgcGFyc2VkLnN0cmlwZSAmJiAhaW5pdENoZWNrb3V0Q2FsbGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGluaXRDaGVja291dENhbGxlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHBhcnNlZC5zdHJpcGUuaW5pdENoZWNrb3V0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgIGlmIChjaGVja291dFNkaykge1xuICAgICAgICAgIHNhZmVTZXRDb250ZXh0KHBhcnNlZC5zdHJpcGUsIGNoZWNrb3V0U2RrKTtcbiAgICAgICAgICBjaGVja291dFNkay5vbignY2hhbmdlJywgc2V0U2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbcGFyc2VkLCBjdHgsIG9wdGlvbnMsIHNldFNlc3Npb25dKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wXG5cbiAgdmFyIHByZXZTdHJpcGUgPSB1c2VQcmV2aW91cyhyYXdTdHJpcGVQcm9wKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJldlN0cmlwZSAhPT0gbnVsbCAmJiBwcmV2U3RyaXBlICE9PSByYXdTdHJpcGVQcm9wKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBgc3RyaXBlYCBwcm9wIGFmdGVyIHNldHRpbmcgaXQuJyk7XG4gICAgfVxuICB9LCBbcHJldlN0cmlwZSwgcmF3U3RyaXBlUHJvcF0pOyAvLyBBcHBseSB1cGRhdGVzIHRvIGVsZW1lbnRzIHdoZW4gb3B0aW9ucyBwcm9wIGhhcyByZWxldmFudCBjaGFuZ2VzXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIHZhciBwcmV2Q2hlY2tvdXRTZGsgPSB1c2VQcmV2aW91cyhjdHguY2hlY2tvdXRTZGspO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcHJldk9wdGlvbnMkZWxlbWVudHMsIF9vcHRpb25zJGVsZW1lbnRzT3B0aTtcblxuICAgIC8vIElnbm9yZSBjaGFuZ2VzIHdoaWxlIGNoZWNrb3V0IHNkayBpcyBub3QgaW5pdGlhbGl6ZWQuXG4gICAgaWYgKCFjdHguY2hlY2tvdXRTZGspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNBcHBlYXJhbmNlID0gcHJldk9wdGlvbnMgPT09IG51bGwgfHwgcHJldk9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfcHJldk9wdGlvbnMkZWxlbWVudHMgPSBwcmV2T3B0aW9ucy5lbGVtZW50c09wdGlvbnMpID09PSBudWxsIHx8IF9wcmV2T3B0aW9ucyRlbGVtZW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXZPcHRpb25zJGVsZW1lbnRzLmFwcGVhcmFuY2U7XG4gICAgdmFyIGN1cnJlbnRBcHBlYXJhbmNlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX29wdGlvbnMkZWxlbWVudHNPcHRpID0gb3B0aW9ucy5lbGVtZW50c09wdGlvbnMpID09PSBudWxsIHx8IF9vcHRpb25zJGVsZW1lbnRzT3B0aSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkZWxlbWVudHNPcHRpLmFwcGVhcmFuY2U7XG4gICAgdmFyIGhhc0FwcGVhcmFuY2VDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEFwcGVhcmFuY2UsIHByZXZpb3VzQXBwZWFyYW5jZSk7XG4gICAgdmFyIGhhc1Nka0xvYWRlZCA9ICFwcmV2Q2hlY2tvdXRTZGsgJiYgY3R4LmNoZWNrb3V0U2RrO1xuXG4gICAgaWYgKGN1cnJlbnRBcHBlYXJhbmNlICYmIChoYXNBcHBlYXJhbmNlQ2hhbmdlZCB8fCBoYXNTZGtMb2FkZWQpKSB7XG4gICAgICBjdHguY2hlY2tvdXRTZGsuY2hhbmdlQXBwZWFyYW5jZShjdXJyZW50QXBwZWFyYW5jZSk7XG4gICAgfVxuICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnMsIGN0eC5jaGVja291dFNkaywgcHJldkNoZWNrb3V0U2RrXSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGN0eC5zdHJpcGUpO1xuICB9LCBbY3R4LnN0cmlwZV0pO1xuICB2YXIgY2hlY2tvdXRDb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXh0cmFjdENoZWNrb3V0Q29udGV4dFZhbHVlKGN0eC5jaGVja291dFNkaywgc2Vzc2lvbik7XG4gIH0sIFtjdHguY2hlY2tvdXRTZGssIHNlc3Npb25dKTtcblxuICBpZiAoIWN0eC5jaGVja291dFNkaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrb3V0U2RrQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjdHhcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tvdXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNoZWNrb3V0Q29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKSk7XG59O1xuQ2hlY2tvdXRQcm92aWRlci5wcm9wVHlwZXMgPSB7XG4gIHN0cmlwZTogUHJvcFR5cGVzLmFueSxcbiAgb3B0aW9uczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBmZXRjaENsaWVudFNlY3JldDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBlbGVtZW50c09wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfSkuaXNSZXF1aXJlZFxufTtcbnZhciB1c2VDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUNoZWNrb3V0U2RrQ29udGV4dFdpdGhVc2VDYXNlKHVzZUNhc2VTdHJpbmcpIHtcbiAgdmFyIGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ2hlY2tvdXRTZGtDb250ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0KGN0eCwgdXNlQ2FzZVN0cmluZyk7XG59O1xudmFyIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSA9IGZ1bmN0aW9uIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSh1c2VDYXNlU3RyaW5nKSB7XG4gIHZhciBjaGVja291dFNka0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENoZWNrb3V0U2RrQ29udGV4dCk7XG4gIHZhciBlbGVtZW50c0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEVsZW1lbnRzQ29udGV4dCk7XG5cbiAgaWYgKGNoZWNrb3V0U2RrQ29udGV4dCAmJiBlbGVtZW50c0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHdyYXAgdGhlIHBhcnQgb2YgeW91ciBhcHAgdGhhdCBcIi5jb25jYXQodXNlQ2FzZVN0cmluZywgXCIgaW4gYm90aCA8Q2hlY2tvdXRQcm92aWRlcj4gYW5kIDxFbGVtZW50cz4gcHJvdmlkZXJzLlwiKSk7XG4gIH1cblxuICBpZiAoY2hlY2tvdXRTZGtDb250ZXh0KSB7XG4gICAgcmV0dXJuIHBhcnNlQ2hlY2tvdXRTZGtDb250ZXh0KGNoZWNrb3V0U2RrQ29udGV4dCwgdXNlQ2FzZVN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VFbGVtZW50c0NvbnRleHQoZWxlbWVudHNDb250ZXh0LCB1c2VDYXNlU3RyaW5nKTtcbn07XG52YXIgdXNlQ2hlY2tvdXQgPSBmdW5jdGlvbiB1c2VDaGVja291dCgpIHtcbiAgLy8gZW5zdXJlIGl0J3MgaW4gQ2hlY2tvdXRQcm92aWRlclxuICB1c2VDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZSgnY2FsbHMgdXNlQ2hlY2tvdXQoKScpO1xuICB2YXIgY3R4ID0gUmVhY3QudXNlQ29udGV4dChDaGVja291dENvbnRleHQpO1xuXG4gIGlmICghY3R4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBDaGVja291dCBDb250ZXh0OyBZb3UgbmVlZCB0byB3cmFwIHRoZSBwYXJ0IG9mIHlvdXIgYXBwIHRoYXQgY2FsbHMgdXNlQ2hlY2tvdXQoKSBpbiBhbiA8Q2hlY2tvdXRQcm92aWRlcj4gcHJvdmlkZXIuJyk7XG4gIH1cblxuICByZXR1cm4gY3R4O1xufTtcblxudmFyIF9leGNsdWRlZCA9IFtcIm1vZGVcIl07XG5cbnZhciBjYXBpdGFsaXplZCA9IGZ1bmN0aW9uIGNhcGl0YWxpemVkKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcblxudmFyIGNyZWF0ZUVsZW1lbnRDb21wb25lbnQgPSBmdW5jdGlvbiBjcmVhdGVFbGVtZW50Q29tcG9uZW50KHR5cGUsIGlzU2VydmVyKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFwiXCIuY29uY2F0KGNhcGl0YWxpemVkKHR5cGUpLCBcIkVsZW1lbnRcIik7XG5cbiAgdmFyIENsaWVudEVsZW1lbnQgPSBmdW5jdGlvbiBDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgICB2YXIgaWQgPSBfcmVmLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgb25CbHVyID0gX3JlZi5vbkJsdXIsXG4gICAgICAgIG9uRm9jdXMgPSBfcmVmLm9uRm9jdXMsXG4gICAgICAgIG9uUmVhZHkgPSBfcmVmLm9uUmVhZHksXG4gICAgICAgIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZSxcbiAgICAgICAgb25Fc2NhcGUgPSBfcmVmLm9uRXNjYXBlLFxuICAgICAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgICBvbkxvYWRFcnJvciA9IF9yZWYub25Mb2FkRXJyb3IsXG4gICAgICAgIG9uTG9hZGVyU3RhcnQgPSBfcmVmLm9uTG9hZGVyU3RhcnQsXG4gICAgICAgIG9uTmV0d29ya3NDaGFuZ2UgPSBfcmVmLm9uTmV0d29ya3NDaGFuZ2UsXG4gICAgICAgIG9uQ29uZmlybSA9IF9yZWYub25Db25maXJtLFxuICAgICAgICBvbkNhbmNlbCA9IF9yZWYub25DYW5jZWwsXG4gICAgICAgIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlID0gX3JlZi5vblNoaXBwaW5nQWRkcmVzc0NoYW5nZSxcbiAgICAgICAgb25TaGlwcGluZ1JhdGVDaGFuZ2UgPSBfcmVmLm9uU2hpcHBpbmdSYXRlQ2hhbmdlO1xuICAgIHZhciBjdHggPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoXCJtb3VudHMgPFwiLmNvbmNhdChkaXNwbGF5TmFtZSwgXCI+XCIpKTtcbiAgICB2YXIgZWxlbWVudHMgPSAnZWxlbWVudHMnIGluIGN0eCA/IGN0eC5lbGVtZW50cyA6IG51bGw7XG4gICAgdmFyIGNoZWNrb3V0U2RrID0gJ2NoZWNrb3V0U2RrJyBpbiBjdHggPyBjdHguY2hlY2tvdXRTZGsgOiBudWxsO1xuXG4gICAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLFxuICAgICAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICAgICAgZWxlbWVudCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgICAgIHNldEVsZW1lbnQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gICAgdmFyIGVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIGRvbU5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIEZvciBldmVyeSBldmVudCB3aGVyZSB0aGUgbWVyY2hhbnQgcHJvdmlkZXMgYSBjYWxsYmFjaywgY2FsbCBlbGVtZW50Lm9uXG4gICAgLy8gd2l0aCB0aGF0IGNhbGxiYWNrLiBJZiB0aGUgbWVyY2hhbnQgZXZlciBjaGFuZ2VzIHRoZSBjYWxsYmFjaywgcmVtb3Zlc1xuICAgIC8vIHRoZSBvbGQgY2FsbGJhY2sgd2l0aCBlbGVtZW50Lm9mZiBhbmQgdGhlbiBjYWxsIGVsZW1lbnQub24gd2l0aCB0aGUgbmV3IG9uZS5cblxuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdibHVyJywgb25CbHVyKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZm9jdXMnLCBvbkZvY3VzKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnZXNjYXBlJywgb25Fc2NhcGUpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdsb2FkZXJyb3InLCBvbkxvYWRFcnJvcik7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2xvYWRlcnN0YXJ0Jywgb25Mb2FkZXJTdGFydCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ25ldHdvcmtzY2hhbmdlJywgb25OZXR3b3Jrc0NoYW5nZSk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ2NvbmZpcm0nLCBvbkNvbmZpcm0pO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjYW5jZWwnLCBvbkNhbmNlbCk7XG4gICAgdXNlQXR0YWNoRXZlbnQoZWxlbWVudCwgJ3NoaXBwaW5nYWRkcmVzc2NoYW5nZScsIG9uU2hpcHBpbmdBZGRyZXNzQ2hhbmdlKTtcbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAnc2hpcHBpbmdyYXRlY2hhbmdlJywgb25TaGlwcGluZ1JhdGVDaGFuZ2UpO1xuICAgIHVzZUF0dGFjaEV2ZW50KGVsZW1lbnQsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgdmFyIHJlYWR5Q2FsbGJhY2s7XG5cbiAgICBpZiAob25SZWFkeSkge1xuICAgICAgaWYgKHR5cGUgPT09ICdleHByZXNzQ2hlY2tvdXQnKSB7XG4gICAgICAgIC8vIFBhc3NlcyB0aHJvdWdoIHRoZSBldmVudCwgd2hpY2ggaW5jbHVkZXMgdmlzaWJsZSBQTSB0eXBlc1xuICAgICAgICByZWFkeUNhbGxiYWNrID0gb25SZWFkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvdGhlciBFbGVtZW50cywgcGFzcyB0aHJvdWdoIHRoZSBFbGVtZW50IGl0c2VsZi5cbiAgICAgICAgcmVhZHlDYWxsYmFjayA9IGZ1bmN0aW9uIHJlYWR5Q2FsbGJhY2soKSB7XG4gICAgICAgICAgb25SZWFkeShlbGVtZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1c2VBdHRhY2hFdmVudChlbGVtZW50LCAncmVhZHknLCByZWFkeUNhbGxiYWNrKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCA9PT0gbnVsbCAmJiBkb21Ob2RlLmN1cnJlbnQgIT09IG51bGwgJiYgKGVsZW1lbnRzIHx8IGNoZWNrb3V0U2RrKSkge1xuICAgICAgICB2YXIgbmV3RWxlbWVudCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNoZWNrb3V0U2RrKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwYXltZW50JzpcbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZVBheW1lbnRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICAgIGlmICgnbW9kZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXN0T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdzaGlwcGluZycpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVTaGlwcGluZ0FkZHJlc3NFbGVtZW50KHJlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdiaWxsaW5nJykge1xuICAgICAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IGNoZWNrb3V0U2RrLmNyZWF0ZUJpbGxpbmdBZGRyZXNzRWxlbWVudChyZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9ucy5tb2RlLiBtb2RlIG11c3QgYmUgJ2JpbGxpbmcnIG9yICdzaGlwcGluZycuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgb3B0aW9ucy5tb2RlLiBtb2RlIG11c3QgYmUgJ2JpbGxpbmcnIG9yICdzaGlwcGluZycuXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2V4cHJlc3NDaGVja291dCc6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVFeHByZXNzQ2hlY2tvdXRFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnY3VycmVuY3lTZWxlY3Rvcic6XG4gICAgICAgICAgICAgIG5ld0VsZW1lbnQgPSBjaGVja291dFNkay5jcmVhdGVDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBFbGVtZW50IHR5cGUgXCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIi4gWW91IG11c3QgdXNlIGVpdGhlciB0aGUgPFBheW1lbnRFbGVtZW50IC8+LCA8QWRkcmVzc0VsZW1lbnQgb3B0aW9ucz17e21vZGU6ICdzaGlwcGluZyd9fSAvPiwgPEFkZHJlc3NFbGVtZW50IG9wdGlvbnM9e3ttb2RlOiAnYmlsbGluZyd9fSAvPiwgb3IgPEV4cHJlc3NDaGVja291dEVsZW1lbnQgLz4uXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICBuZXdFbGVtZW50ID0gZWxlbWVudHMuY3JlYXRlKHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9IC8vIFN0b3JlIGVsZW1lbnQgaW4gYSByZWYgdG8gZW5zdXJlIGl0J3MgX2ltbWVkaWF0ZWx5XyBhdmFpbGFibGUgaW4gY2xlYW51cCBob29rcyBpbiBTdHJpY3RNb2RlXG5cblxuICAgICAgICBlbGVtZW50UmVmLmN1cnJlbnQgPSBuZXdFbGVtZW50OyAvLyBTdG9yZSBlbGVtZW50IGluIHN0YXRlIHRvIGZhY2lsaXRhdGUgZXZlbnQgbGlzdGVuZXIgYXR0YWNobWVudFxuXG4gICAgICAgIHNldEVsZW1lbnQobmV3RWxlbWVudCk7XG5cbiAgICAgICAgaWYgKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICBuZXdFbGVtZW50Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbZWxlbWVudHMsIGNoZWNrb3V0U2RrLCBvcHRpb25zXSk7XG4gICAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZXMgPSBleHRyYWN0QWxsb3dlZE9wdGlvbnNVcGRhdGVzKG9wdGlvbnMsIHByZXZPcHRpb25zLCBbJ3BheW1lbnRSZXF1ZXN0J10pO1xuXG4gICAgICBpZiAodXBkYXRlcyAmJiAndXBkYXRlJyBpbiBlbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LnVwZGF0ZSh1cGRhdGVzKTtcbiAgICAgIH1cbiAgICB9LCBbb3B0aW9ucywgcHJldk9wdGlvbnNdKTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVsZW1lbnRSZWYuY3VycmVudCAmJiB0eXBlb2YgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWxlbWVudFJlZi5jdXJyZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBEbyBub3RoaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICByZWY6IGRvbU5vZGVcbiAgICB9KTtcbiAgfTsgLy8gT25seSByZW5kZXIgdGhlIEVsZW1lbnQgd3JhcHBlciBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cblxuXG4gIHZhciBTZXJ2ZXJFbGVtZW50ID0gZnVuY3Rpb24gU2VydmVyRWxlbWVudChwcm9wcykge1xuICAgIHVzZUVsZW1lbnRzT3JDaGVja291dFNka0NvbnRleHRXaXRoVXNlQ2FzZShcIm1vdW50cyA8XCIuY29uY2F0KGRpc3BsYXlOYW1lLCBcIj5cIikpO1xuICAgIHZhciBpZCA9IHByb3BzLmlkLFxuICAgICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWU7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEVsZW1lbnQgPSBpc1NlcnZlciA/IFNlcnZlckVsZW1lbnQgOiBDbGllbnRFbGVtZW50O1xuICBFbGVtZW50LnByb3BUeXBlcyA9IHtcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQmx1cjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZWFkeTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Fc2NhcGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTG9hZEVycm9yOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRlclN0YXJ0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbk5ldHdvcmtzQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNvbmZpcm06IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2FuY2VsOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNoaXBwaW5nQWRkcmVzc0NoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25TaGlwcGluZ1JhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcbiAgRWxlbWVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBFbGVtZW50Ll9fZWxlbWVudFR5cGUgPSB0eXBlO1xuICByZXR1cm4gRWxlbWVudDtcbn07XG5cbnZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG52YXIgRW1iZWRkZWRDaGVja291dENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbkVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0VtYmVkZGVkQ2hlY2tvdXRQcm92aWRlckNvbnRleHQnO1xudmFyIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0ID0gZnVuY3Rpb24gdXNlRW1iZWRkZWRDaGVja291dENvbnRleHQoKSB7XG4gIHZhciBjdHggPSBSZWFjdC51c2VDb250ZXh0KEVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0KTtcblxuICBpZiAoIWN0eCkge1xuICAgIHRocm93IG5ldyBFcnJvcignPEVtYmVkZGVkQ2hlY2tvdXQ+IG11c3QgYmUgdXNlZCB3aXRoaW4gPEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBjdHg7XG59O1xudmFyIElOVkFMSURfU1RSSVBFX0VSUk9SID0gJ0ludmFsaWQgcHJvcCBgc3RyaXBlYCBzdXBwbGllZCB0byBgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyYC4gV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgbG9hZFN0cmlwZWAgdXRpbGl0eSBmcm9tIGBAc3RyaXBlL3N0cmlwZS1qc2AuIFNlZSBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudHMtcHJvcHMtc3RyaXBlIGZvciBkZXRhaWxzLic7XG52YXIgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyID0gZnVuY3Rpb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHJhd1N0cmlwZVByb3AgPSBfcmVmLnN0cmlwZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBwYXJzZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VTdHJpcGVQcm9wKHJhd1N0cmlwZVByb3AsIElOVkFMSURfU1RSSVBFX0VSUk9SKTtcbiAgfSwgW3Jhd1N0cmlwZVByb3BdKTtcbiAgdmFyIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgbG9hZGVkU3RyaXBlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgZW1iZWRkZWRDaGVja291dDogbnVsbFxuICB9KSxcbiAgICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgICAgY3R4ID0gX1JlYWN0JHVzZVN0YXRlMlswXSxcbiAgICAgIHNldENvbnRleHQgPSBfUmVhY3QkdXNlU3RhdGUyWzFdO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gRG9uJ3Qgc3VwcG9ydCBhbnkgY3R4IHVwZGF0ZXMgb25jZSBlbWJlZGRlZENoZWNrb3V0IG9yIHN0cmlwZSBpcyBzZXQuXG4gICAgaWYgKGxvYWRlZFN0cmlwZS5jdXJyZW50IHx8IGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2V0U3RyaXBlQW5kSW5pdEVtYmVkZGVkQ2hlY2tvdXQgPSBmdW5jdGlvbiBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChzdHJpcGUpIHtcbiAgICAgIGlmIChsb2FkZWRTdHJpcGUuY3VycmVudCB8fCBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50KSByZXR1cm47XG4gICAgICBsb2FkZWRTdHJpcGUuY3VycmVudCA9IHN0cmlwZTtcbiAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBsb2FkZWRTdHJpcGUuY3VycmVudC5pbml0RW1iZWRkZWRDaGVja291dChvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChlbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIHNldENvbnRleHQoe1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXQ6IGVtYmVkZGVkQ2hlY2tvdXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9OyAvLyBGb3IgYW4gYXN5bmMgc3RyaXBlUHJvbWlzZSwgc3RvcmUgaXQgb25jZSByZXNvbHZlZFxuXG5cbiAgICBpZiAocGFyc2VkLnRhZyA9PT0gJ2FzeW5jJyAmJiAhbG9hZGVkU3RyaXBlLmN1cnJlbnQgJiYgKG9wdGlvbnMuY2xpZW50U2VjcmV0IHx8IG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpKSB7XG4gICAgICBwYXJzZWQuc3RyaXBlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzdHJpcGUpIHtcbiAgICAgICAgaWYgKHN0cmlwZSkge1xuICAgICAgICAgIHNldFN0cmlwZUFuZEluaXRFbWJlZGRlZENoZWNrb3V0KHN0cmlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnRhZyA9PT0gJ3N5bmMnICYmICFsb2FkZWRTdHJpcGUuY3VycmVudCAmJiAob3B0aW9ucy5jbGllbnRTZWNyZXQgfHwgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCkpIHtcbiAgICAgIC8vIE9yLCBoYW5kbGUgYSBzeW5jIHN0cmlwZSBpbnN0YW5jZSBnb2luZyBmcm9tIG51bGwgLT4gcG9wdWxhdGVkXG4gICAgICBzZXRTdHJpcGVBbmRJbml0RW1iZWRkZWRDaGVja291dChwYXJzZWQuc3RyaXBlKTtcbiAgICB9XG4gIH0sIFtwYXJzZWQsIG9wdGlvbnMsIGN0eCwgbG9hZGVkU3RyaXBlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIElmIGVtYmVkZGVkIGNoZWNrb3V0IGlzIGZ1bGx5IGluaXRpYWxpemVkLCBkZXN0cm95IGl0LlxuICAgICAgaWYgKGN0eC5lbWJlZGRlZENoZWNrb3V0KSB7XG4gICAgICAgIGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBjdHguZW1iZWRkZWRDaGVja291dC5kZXN0cm95KCk7XG4gICAgICB9IGVsc2UgaWYgKGVtYmVkZGVkQ2hlY2tvdXRQcm9taXNlLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gSWYgZW1iZWRkZWQgY2hlY2tvdXQgaXMgc3RpbGwgaW5pdGlhbGl6aW5nLCBkZXN0cm95IGl0IG9uY2VcbiAgICAgICAgLy8gaXQncyBkb25lLiBUaGlzIGNvdWxkIGJlIGNhdXNlZCBieSB1bm1vdW50aW5nIHZlcnkgcXVpY2tseVxuICAgICAgICAvLyBhZnRlciBtb3VudGluZy5cbiAgICAgICAgZW1iZWRkZWRDaGVja291dFByb21pc2UuY3VycmVudC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbWJlZGRlZENoZWNrb3V0UHJvbWlzZS5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChjdHguZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICAgICAgY3R4LmVtYmVkZGVkQ2hlY2tvdXQuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N0eC5lbWJlZGRlZENoZWNrb3V0XSk7IC8vIEF0dGFjaCByZWFjdC1zdHJpcGUtanMgdmVyc2lvbiB0byBzdHJpcGUuanMgaW5zdGFuY2VcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZ2lzdGVyV2l0aFN0cmlwZUpzKGxvYWRlZFN0cmlwZSk7XG4gIH0sIFtsb2FkZWRTdHJpcGVdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIHN0cmlwZSBwcm9wLlxuICAvLyBUaGUgc3RyaXBlIHByb3AgdmFsdWUgY2FuIG9ubHkgZ28gZnJvbSBudWxsIHRvIG5vbi1udWxsIG9uY2UgYW5kXG4gIC8vIGNhbid0IGJlIGNoYW5nZWQgYWZ0ZXIgdGhhdC5cblxuICB2YXIgcHJldlN0cmlwZSA9IHVzZVByZXZpb3VzKHJhd1N0cmlwZVByb3ApO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2U3RyaXBlICE9PSBudWxsICYmIHByZXZTdHJpcGUgIT09IHJhd1N0cmlwZVByb3ApIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgYHN0cmlwZWAgcHJvcCBhZnRlciBzZXR0aW5nIGl0LicpO1xuICAgIH1cbiAgfSwgW3ByZXZTdHJpcGUsIHJhd1N0cmlwZVByb3BdKTsgLy8gV2FybiBvbiBjaGFuZ2VzIHRvIG9wdGlvbnMuXG5cbiAgdmFyIHByZXZPcHRpb25zID0gdXNlUHJldmlvdXMob3B0aW9ucyk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByZXZPcHRpb25zID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1Vuc3VwcG9ydGVkIHByb3AgY2hhbmdlIG9uIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlcjogWW91IGNhbm5vdCB1bnNldCBvcHRpb25zIGFmdGVyIHNldHRpbmcgdGhlbS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbGllbnRTZWNyZXQgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCBwcm9wcyBwYXNzZWQgdG8gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgbXVzdCBwcm92aWRlIG9uZSBvZiBlaXRoZXIgYG9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXRgIG9yIGBvcHRpb25zLmNsaWVudFNlY3JldGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLmNsaWVudFNlY3JldCAhPSBudWxsICYmIG9wdGlvbnMuY2xpZW50U2VjcmV0ICE9PSBwcmV2T3B0aW9ucy5jbGllbnRTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgY2xpZW50IHNlY3JldCBhZnRlciBzZXR0aW5nIGl0LiBVbm1vdW50IGFuZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLmZldGNoQ2xpZW50U2VjcmV0ICE9IG51bGwgJiYgb3B0aW9ucy5mZXRjaENsaWVudFNlY3JldCAhPT0gcHJldk9wdGlvbnMuZmV0Y2hDbGllbnRTZWNyZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSBmZXRjaENsaWVudFNlY3JldCBhZnRlciBzZXR0aW5nIGl0LiBVbm1vdW50IGFuZCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPcHRpb25zLm9uQ29tcGxldGUgIT0gbnVsbCAmJiBvcHRpb25zLm9uQ29tcGxldGUgIT09IHByZXZPcHRpb25zLm9uQ29tcGxldGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgcHJvcCBjaGFuZ2Ugb24gRW1iZWRkZWRDaGVja291dFByb3ZpZGVyOiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgb25Db21wbGV0ZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25TaGlwcGluZ0RldGFpbHNDaGFuZ2UgIT0gbnVsbCAmJiBvcHRpb25zLm9uU2hpcHBpbmdEZXRhaWxzQ2hhbmdlICE9PSBwcmV2T3B0aW9ucy5vblNoaXBwaW5nRGV0YWlsc0NoYW5nZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvblNoaXBwaW5nRGV0YWlsc0NoYW5nZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJldk9wdGlvbnMub25MaW5lSXRlbXNDaGFuZ2UgIT0gbnVsbCAmJiBvcHRpb25zLm9uTGluZUl0ZW1zQ2hhbmdlICE9PSBwcmV2T3B0aW9ucy5vbkxpbmVJdGVtc0NoYW5nZSkge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBwcm9wIGNoYW5nZSBvbiBFbWJlZGRlZENoZWNrb3V0UHJvdmlkZXI6IFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvbkxpbmVJdGVtc0NoYW5nZSBvcHRpb24gYWZ0ZXIgc2V0dGluZyBpdC4nKTtcbiAgICB9XG4gIH0sIFtwcmV2T3B0aW9ucywgb3B0aW9uc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW1iZWRkZWRDaGVja291dENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4XG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0Q2xpZW50RWxlbWVudCA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50KF9yZWYpIHtcbiAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuXG4gIHZhciBfdXNlRW1iZWRkZWRDaGVja291dEMgPSB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpLFxuICAgICAgZW1iZWRkZWRDaGVja291dCA9IF91c2VFbWJlZGRlZENoZWNrb3V0Qy5lbWJlZGRlZENoZWNrb3V0O1xuXG4gIHZhciBpc01vdW50ZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICB2YXIgZG9tTm9kZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTW91bnRlZC5jdXJyZW50ICYmIGVtYmVkZGVkQ2hlY2tvdXQgJiYgZG9tTm9kZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBlbWJlZGRlZENoZWNrb3V0Lm1vdW50KGRvbU5vZGUuY3VycmVudCk7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfSAvLyBDbGVhbiB1cCBvbiB1bm1vdW50XG5cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgJiYgZW1iZWRkZWRDaGVja291dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGVtYmVkZGVkQ2hlY2tvdXQudW5tb3VudCgpO1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsvLyBEbyBub3RoaW5nLlxuICAgICAgICAgIC8vIFBhcmVudCBlZmZlY3RzIGFyZSBkZXN0cm95ZWQgYmVmb3JlIGNoaWxkIGVmZmVjdHMsIHNvXG4gICAgICAgICAgLy8gaW4gY2FzZXMgd2hlcmUgYm90aCB0aGUgRW1iZWRkZWRDaGVja291dFByb3ZpZGVyIGFuZFxuICAgICAgICAgIC8vIHRoZSBFbWJlZGRlZENoZWNrb3V0IGNvbXBvbmVudCBhcmUgcmVtb3ZlZCBhdCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHRpbWUsIHRoZSBlbWJlZGRlZENoZWNrb3V0IGluc3RhbmNlIHdpbGwgYmUgZGVzdHJveWVkLFxuICAgICAgICAgIC8vIHdoaWNoIGNhdXNlcyBhbiBlcnJvciB3aGVuIGNhbGxpbmcgdW5tb3VudC5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbWJlZGRlZENoZWNrb3V0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBkb21Ob2RlLFxuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KTtcbn07IC8vIE9ubHkgcmVuZGVyIHRoZSB3cmFwcGVyIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuXG5cbnZhciBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCA9IGZ1bmN0aW9uIEVtYmVkZGVkQ2hlY2tvdXRTZXJ2ZXJFbGVtZW50KF9yZWYyKSB7XG4gIHZhciBpZCA9IF9yZWYyLmlkLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjIuY2xhc3NOYW1lO1xuICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGFyZSBpbiB0aGUgcmlnaHQgY29udGV4dCBieSBjYWxsaW5nIHVzZUVtYmVkZGVkQ2hlY2tvdXRDb250ZXh0LlxuICB1c2VFbWJlZGRlZENoZWNrb3V0Q29udGV4dCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9KTtcbn07XG5cbnZhciBFbWJlZGRlZENoZWNrb3V0ID0gaXNTZXJ2ZXIgPyBFbWJlZGRlZENoZWNrb3V0U2VydmVyRWxlbWVudCA6IEVtYmVkZGVkQ2hlY2tvdXRDbGllbnRFbGVtZW50O1xuXG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCN1c2VzdHJpcGUtaG9va1xuICovXG5cbnZhciB1c2VTdHJpcGUgPSBmdW5jdGlvbiB1c2VTdHJpcGUoKSB7XG4gIHZhciBfdXNlRWxlbWVudHNPckNoZWNrb3UgPSB1c2VFbGVtZW50c09yQ2hlY2tvdXRTZGtDb250ZXh0V2l0aFVzZUNhc2UoJ2NhbGxzIHVzZVN0cmlwZSgpJyksXG4gICAgICBzdHJpcGUgPSBfdXNlRWxlbWVudHNPckNoZWNrb3Uuc3RyaXBlO1xuXG4gIHJldHVybiBzdHJpcGU7XG59O1xuXG4vKipcbiAqIFJlcXVpcmVzIGJldGEgYWNjZXNzOlxuICogQ29udGFjdCBbU3RyaXBlIHN1cHBvcnRdKGh0dHBzOi8vc3VwcG9ydC5zdHJpcGUuY29tLykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBdUJhbmtBY2NvdW50RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2F1QmFua0FjY291bnQnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIENhcmROdW1iZXJFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnY2FyZE51bWJlcicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBDYXJkRXhwaXJ5RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2NhcmRFeHBpcnknLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQ2FyZEN2Y0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdjYXJkQ3ZjJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEZweEJhbmtFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZnB4QmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBJYmFuRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2liYW4nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgSWRlYWxCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2lkZWFsQmFuaycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQMjRCYW5rRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3AyNEJhbmsnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgRXBzQmFua0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdlcHNCYW5rJywgaXNTZXJ2ZXIpO1xudmFyIFBheW1lbnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudCcsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBFeHByZXNzQ2hlY2tvdXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgnZXhwcmVzc0NoZWNrb3V0JywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBSZXF1aXJlcyBiZXRhIGFjY2VzczpcbiAqIENvbnRhY3QgW1N0cmlwZSBzdXBwb3J0XShodHRwczovL3N1cHBvcnQuc3RyaXBlLmNvbS8pIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5cbnZhciBDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2N1cnJlbmN5U2VsZWN0b3InLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50ID0gY3JlYXRlRWxlbWVudENvbXBvbmVudCgncGF5bWVudFJlcXVlc3RCdXR0b24nLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2xpbmtBdXRoZW50aWNhdGlvbicsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FkZHJlc3MnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBVc2UgYEFkZHJlc3NFbGVtZW50YCBpbnN0ZWFkLlxuICpcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgU2hpcHBpbmdBZGRyZXNzRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3NoaXBwaW5nQWRkcmVzcycsIGlzU2VydmVyKTtcbi8qKlxuICogQGRvY3MgaHR0cHM6Ly9zdHJpcGUuY29tL2RvY3Mvc3RyaXBlLWpzL3JlYWN0I2VsZW1lbnQtY29tcG9uZW50c1xuICovXG5cbnZhciBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ3BheW1lbnRNZXRob2RNZXNzYWdpbmcnLCBpc1NlcnZlcik7XG4vKipcbiAqIEBkb2NzIGh0dHBzOi8vc3RyaXBlLmNvbS9kb2NzL3N0cmlwZS1qcy9yZWFjdCNlbGVtZW50LWNvbXBvbmVudHNcbiAqL1xuXG52YXIgQWZmaXJtTWVzc2FnZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50Q29tcG9uZW50KCdhZmZpcm1NZXNzYWdlJywgaXNTZXJ2ZXIpO1xuLyoqXG4gKiBAZG9jcyBodHRwczovL3N0cmlwZS5jb20vZG9jcy9zdHJpcGUtanMvcmVhY3QjZWxlbWVudC1jb21wb25lbnRzXG4gKi9cblxudmFyIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnRDb21wb25lbnQoJ2FmdGVycGF5Q2xlYXJwYXlNZXNzYWdlJywgaXNTZXJ2ZXIpO1xuXG5leHBvcnQgeyBBZGRyZXNzRWxlbWVudCwgQWZmaXJtTWVzc2FnZUVsZW1lbnQsIEFmdGVycGF5Q2xlYXJwYXlNZXNzYWdlRWxlbWVudCwgQXVCYW5rQWNjb3VudEVsZW1lbnQsIENhcmRDdmNFbGVtZW50LCBDYXJkRWxlbWVudCwgQ2FyZEV4cGlyeUVsZW1lbnQsIENhcmROdW1iZXJFbGVtZW50LCBDaGVja291dFByb3ZpZGVyLCBDdXJyZW5jeVNlbGVjdG9yRWxlbWVudCwgRWxlbWVudHMsIEVsZW1lbnRzQ29uc3VtZXIsIEVtYmVkZGVkQ2hlY2tvdXQsIEVtYmVkZGVkQ2hlY2tvdXRQcm92aWRlciwgRXBzQmFua0VsZW1lbnQsIEV4cHJlc3NDaGVja291dEVsZW1lbnQsIEZweEJhbmtFbGVtZW50LCBJYmFuRWxlbWVudCwgSWRlYWxCYW5rRWxlbWVudCwgTGlua0F1dGhlbnRpY2F0aW9uRWxlbWVudCwgUDI0QmFua0VsZW1lbnQsIFBheW1lbnRFbGVtZW50LCBQYXltZW50TWV0aG9kTWVzc2FnaW5nRWxlbWVudCwgUGF5bWVudFJlcXVlc3RCdXR0b25FbGVtZW50LCBTaGlwcGluZ0FkZHJlc3NFbGVtZW50LCB1c2VDaGVja291dCwgdXNlRWxlbWVudHMsIHVzZVN0cmlwZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/react-stripe-js/dist/react-stripe.esm.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* binding */ loadStripe)\n/* harmony export */ });\nvar RELEASE_TRAIN = 'basil';\n\nvar runtimeVersionToUrlVersion = function runtimeVersionToUrlVersion(version) {\n  return version === 3 ? 'v3' : version;\n};\n\nvar ORIGIN = 'https://js.stripe.com';\nvar STRIPE_JS_URL = \"\".concat(ORIGIN, \"/\").concat(RELEASE_TRAIN, \"/stripe.js\");\nvar V3_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/v3\\/?(\\?.*)?$/;\nvar STRIPE_JS_URL_REGEX = /^https:\\/\\/js\\.stripe\\.com\\/(v3|[a-z]+)\\/stripe\\.js(\\?.*)?$/;\nvar EXISTING_SCRIPT_MESSAGE = 'loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used';\n\nvar isStripeJSURL = function isStripeJSURL(url) {\n  return V3_URL_REGEX.test(url) || STRIPE_JS_URL_REGEX.test(url);\n};\n\nvar findScript = function findScript() {\n  var scripts = document.querySelectorAll(\"script[src^=\\\"\".concat(ORIGIN, \"\\\"]\"));\n\n  for (var i = 0; i < scripts.length; i++) {\n    var script = scripts[i];\n\n    if (!isStripeJSURL(script.src)) {\n      continue;\n    }\n\n    return script;\n  }\n\n  return null;\n};\n\nvar injectScript = function injectScript(params) {\n  var queryString = params && !params.advancedFraudSignals ? '?advancedFraudSignals=false' : '';\n  var script = document.createElement('script');\n  script.src = \"\".concat(STRIPE_JS_URL).concat(queryString);\n  var headOrBody = document.head || document.body;\n\n  if (!headOrBody) {\n    throw new Error('Expected document.body not to be null. Stripe.js requires a <body> element.');\n  }\n\n  headOrBody.appendChild(script);\n  return script;\n};\n\nvar registerWrapper = function registerWrapper(stripe, startTime) {\n  if (!stripe || !stripe._registerWrapper) {\n    return;\n  }\n\n  stripe._registerWrapper({\n    name: 'stripe-js',\n    version: \"7.4.0\",\n    startTime: startTime\n  });\n};\n\nvar stripePromise$1 = null;\nvar onErrorListener = null;\nvar onLoadListener = null;\n\nvar onError = function onError(reject) {\n  return function (cause) {\n    reject(new Error('Failed to load Stripe.js', {\n      cause: cause\n    }));\n  };\n};\n\nvar onLoad = function onLoad(resolve, reject) {\n  return function () {\n    if (window.Stripe) {\n      resolve(window.Stripe);\n    } else {\n      reject(new Error('Stripe.js not available'));\n    }\n  };\n};\n\nvar loadScript = function loadScript(params) {\n  // Ensure that we only attempt to load Stripe.js at most once\n  if (stripePromise$1 !== null) {\n    return stripePromise$1;\n  }\n\n  stripePromise$1 = new Promise(function (resolve, reject) {\n    if (typeof window === 'undefined' || typeof document === 'undefined') {\n      // Resolve to null when imported server side. This makes the module\n      // safe to import in an isomorphic code base.\n      resolve(null);\n      return;\n    }\n\n    if (window.Stripe && params) {\n      console.warn(EXISTING_SCRIPT_MESSAGE);\n    }\n\n    if (window.Stripe) {\n      resolve(window.Stripe);\n      return;\n    }\n\n    try {\n      var script = findScript();\n\n      if (script && params) {\n        console.warn(EXISTING_SCRIPT_MESSAGE);\n      } else if (!script) {\n        script = injectScript(params);\n      } else if (script && onLoadListener !== null && onErrorListener !== null) {\n        var _script$parentNode;\n\n        // remove event listeners\n        script.removeEventListener('load', onLoadListener);\n        script.removeEventListener('error', onErrorListener); // if script exists, but we are reloading due to an error,\n        // reload script to trigger 'load' event\n\n        (_script$parentNode = script.parentNode) === null || _script$parentNode === void 0 ? void 0 : _script$parentNode.removeChild(script);\n        script = injectScript(params);\n      }\n\n      onLoadListener = onLoad(resolve, reject);\n      onErrorListener = onError(reject);\n      script.addEventListener('load', onLoadListener);\n      script.addEventListener('error', onErrorListener);\n    } catch (error) {\n      reject(error);\n      return;\n    }\n  }); // Resets stripePromise on error\n\n  return stripePromise$1[\"catch\"](function (error) {\n    stripePromise$1 = null;\n    return Promise.reject(error);\n  });\n};\nvar initStripe = function initStripe(maybeStripe, args, startTime) {\n  if (maybeStripe === null) {\n    return null;\n  }\n\n  var pk = args[0];\n  var isTestKey = pk.match(/^pk_test/); // @ts-expect-error this is not publicly typed\n\n  var version = runtimeVersionToUrlVersion(maybeStripe.version);\n  var expectedVersion = RELEASE_TRAIN;\n\n  if (isTestKey && version !== expectedVersion) {\n    console.warn(\"Stripe.js@\".concat(version, \" was loaded on the page, but @stripe/stripe-js@\").concat(\"7.4.0\", \" expected Stripe.js@\").concat(expectedVersion, \". This may result in unexpected behavior. For more information, see https://docs.stripe.com/sdks/stripejs-versioning\"));\n  }\n\n  var stripe = maybeStripe.apply(undefined, args);\n  registerWrapper(stripe, startTime);\n  return stripe;\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n\nvar stripePromise;\nvar loadCalled = false;\n\nvar getStripePromise = function getStripePromise() {\n  if (stripePromise) {\n    return stripePromise;\n  }\n\n  stripePromise = loadScript(null)[\"catch\"](function (error) {\n    // clear cache on error\n    stripePromise = null;\n    return Promise.reject(error);\n  });\n  return stripePromise;\n}; // Execute our own script injection after a tick to give users time to do their\n// own script injection.\n\n\nPromise.resolve().then(function () {\n  return getStripePromise();\n})[\"catch\"](function (error) {\n  if (!loadCalled) {\n    console.warn(error);\n  }\n});\nvar loadStripe = function loadStripe() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  loadCalled = true;\n  var startTime = Date.now(); // if previous attempts are unsuccessful, will re-load script\n\n  return getStripePromise().then(function (maybeStripe) {\n    return initStripe(maybeStripe, args, startTime);\n  });\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3STs7QUFFeEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0VBQXNFLGFBQWE7QUFDbkY7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncnVwb3Zpc2lvbmFyaW9zLy4vbm9kZV9tb2R1bGVzL0BzdHJpcGUvc3RyaXBlLWpzL2Rpc3QvaW5kZXgubWpzPzRkN2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFJFTEVBU0VfVFJBSU4gPSAnYmFzaWwnO1xuXG52YXIgcnVudGltZVZlcnNpb25Ub1VybFZlcnNpb24gPSBmdW5jdGlvbiBydW50aW1lVmVyc2lvblRvVXJsVmVyc2lvbih2ZXJzaW9uKSB7XG4gIHJldHVybiB2ZXJzaW9uID09PSAzID8gJ3YzJyA6IHZlcnNpb247XG59O1xuXG52YXIgT1JJR0lOID0gJ2h0dHBzOi8vanMuc3RyaXBlLmNvbSc7XG52YXIgU1RSSVBFX0pTX1VSTCA9IFwiXCIuY29uY2F0KE9SSUdJTiwgXCIvXCIpLmNvbmNhdChSRUxFQVNFX1RSQUlOLCBcIi9zdHJpcGUuanNcIik7XG52YXIgVjNfVVJMX1JFR0VYID0gL15odHRwczpcXC9cXC9qc1xcLnN0cmlwZVxcLmNvbVxcL3YzXFwvPyhcXD8uKik/JC87XG52YXIgU1RSSVBFX0pTX1VSTF9SRUdFWCA9IC9eaHR0cHM6XFwvXFwvanNcXC5zdHJpcGVcXC5jb21cXC8odjN8W2Etel0rKVxcL3N0cmlwZVxcLmpzKFxcPy4qKT8kLztcbnZhciBFWElTVElOR19TQ1JJUFRfTUVTU0FHRSA9ICdsb2FkU3RyaXBlLnNldExvYWRQYXJhbWV0ZXJzIHdhcyBjYWxsZWQgYnV0IGFuIGV4aXN0aW5nIFN0cmlwZS5qcyBzY3JpcHQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRvY3VtZW50OyBleGlzdGluZyBzY3JpcHQgcGFyYW1ldGVycyB3aWxsIGJlIHVzZWQnO1xuXG52YXIgaXNTdHJpcGVKU1VSTCA9IGZ1bmN0aW9uIGlzU3RyaXBlSlNVUkwodXJsKSB7XG4gIHJldHVybiBWM19VUkxfUkVHRVgudGVzdCh1cmwpIHx8IFNUUklQRV9KU19VUkxfUkVHRVgudGVzdCh1cmwpO1xufTtcblxudmFyIGZpbmRTY3JpcHQgPSBmdW5jdGlvbiBmaW5kU2NyaXB0KCkge1xuICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRbc3JjXj1cXFwiXCIuY29uY2F0KE9SSUdJTiwgXCJcXFwiXVwiKSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNjcmlwdCA9IHNjcmlwdHNbaV07XG5cbiAgICBpZiAoIWlzU3RyaXBlSlNVUkwoc2NyaXB0LnNyYykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JpcHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBpbmplY3RTY3JpcHQgPSBmdW5jdGlvbiBpbmplY3RTY3JpcHQocGFyYW1zKSB7XG4gIHZhciBxdWVyeVN0cmluZyA9IHBhcmFtcyAmJiAhcGFyYW1zLmFkdmFuY2VkRnJhdWRTaWduYWxzID8gJz9hZHZhbmNlZEZyYXVkU2lnbmFscz1mYWxzZScgOiAnJztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICBzY3JpcHQuc3JjID0gXCJcIi5jb25jYXQoU1RSSVBFX0pTX1VSTCkuY29uY2F0KHF1ZXJ5U3RyaW5nKTtcbiAgdmFyIGhlYWRPckJvZHkgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgaWYgKCFoZWFkT3JCb2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBkb2N1bWVudC5ib2R5IG5vdCB0byBiZSBudWxsLiBTdHJpcGUuanMgcmVxdWlyZXMgYSA8Ym9keT4gZWxlbWVudC4nKTtcbiAgfVxuXG4gIGhlYWRPckJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgcmV0dXJuIHNjcmlwdDtcbn07XG5cbnZhciByZWdpc3RlcldyYXBwZXIgPSBmdW5jdGlvbiByZWdpc3RlcldyYXBwZXIoc3RyaXBlLCBzdGFydFRpbWUpIHtcbiAgaWYgKCFzdHJpcGUgfHwgIXN0cmlwZS5fcmVnaXN0ZXJXcmFwcGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RyaXBlLl9yZWdpc3RlcldyYXBwZXIoe1xuICAgIG5hbWU6ICdzdHJpcGUtanMnLFxuICAgIHZlcnNpb246IFwiNy40LjBcIixcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcGVQcm9taXNlJDEgPSBudWxsO1xudmFyIG9uRXJyb3JMaXN0ZW5lciA9IG51bGw7XG52YXIgb25Mb2FkTGlzdGVuZXIgPSBudWxsO1xuXG52YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IocmVqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY2F1c2UpIHtcbiAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTdHJpcGUuanMnLCB7XG4gICAgICBjYXVzZTogY2F1c2VcbiAgICB9KSk7XG4gIH07XG59O1xuXG52YXIgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3aW5kb3cuU3RyaXBlKSB7XG4gICAgICByZXNvbHZlKHdpbmRvdy5TdHJpcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdTdHJpcGUuanMgbm90IGF2YWlsYWJsZScpKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgbG9hZFNjcmlwdCA9IGZ1bmN0aW9uIGxvYWRTY3JpcHQocGFyYW1zKSB7XG4gIC8vIEVuc3VyZSB0aGF0IHdlIG9ubHkgYXR0ZW1wdCB0byBsb2FkIFN0cmlwZS5qcyBhdCBtb3N0IG9uY2VcbiAgaWYgKHN0cmlwZVByb21pc2UkMSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdHJpcGVQcm9taXNlJDE7XG4gIH1cblxuICBzdHJpcGVQcm9taXNlJDEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFJlc29sdmUgdG8gbnVsbCB3aGVuIGltcG9ydGVkIHNlcnZlciBzaWRlLiBUaGlzIG1ha2VzIHRoZSBtb2R1bGVcbiAgICAgIC8vIHNhZmUgdG8gaW1wb3J0IGluIGFuIGlzb21vcnBoaWMgY29kZSBiYXNlLlxuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlN0cmlwZSAmJiBwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5TdHJpcGUpIHtcbiAgICAgIHJlc29sdmUod2luZG93LlN0cmlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzY3JpcHQgPSBmaW5kU2NyaXB0KCk7XG5cbiAgICAgIGlmIChzY3JpcHQgJiYgcGFyYW1zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihFWElTVElOR19TQ1JJUFRfTUVTU0FHRSk7XG4gICAgICB9IGVsc2UgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gaW5qZWN0U2NyaXB0KHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKHNjcmlwdCAmJiBvbkxvYWRMaXN0ZW5lciAhPT0gbnVsbCAmJiBvbkVycm9yTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9zY3JpcHQkcGFyZW50Tm9kZTtcblxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkTGlzdGVuZXIpO1xuICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yTGlzdGVuZXIpOyAvLyBpZiBzY3JpcHQgZXhpc3RzLCBidXQgd2UgYXJlIHJlbG9hZGluZyBkdWUgdG8gYW4gZXJyb3IsXG4gICAgICAgIC8vIHJlbG9hZCBzY3JpcHQgdG8gdHJpZ2dlciAnbG9hZCcgZXZlbnRcblxuICAgICAgICAoX3NjcmlwdCRwYXJlbnROb2RlID0gc2NyaXB0LnBhcmVudE5vZGUpID09PSBudWxsIHx8IF9zY3JpcHQkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjcmlwdCRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgIHNjcmlwdCA9IGluamVjdFNjcmlwdChwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBvbkxvYWRMaXN0ZW5lciA9IG9uTG9hZChyZXNvbHZlLCByZWplY3QpO1xuICAgICAgb25FcnJvckxpc3RlbmVyID0gb25FcnJvcihyZWplY3QpO1xuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWRMaXN0ZW5lcik7XG4gICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yTGlzdGVuZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSk7IC8vIFJlc2V0cyBzdHJpcGVQcm9taXNlIG9uIGVycm9yXG5cbiAgcmV0dXJuIHN0cmlwZVByb21pc2UkMVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHN0cmlwZVByb21pc2UkMSA9IG51bGw7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfSk7XG59O1xudmFyIGluaXRTdHJpcGUgPSBmdW5jdGlvbiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpIHtcbiAgaWYgKG1heWJlU3RyaXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGsgPSBhcmdzWzBdO1xuICB2YXIgaXNUZXN0S2V5ID0gcGsubWF0Y2goL15wa190ZXN0Lyk7IC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyBub3QgcHVibGljbHkgdHlwZWRcblxuICB2YXIgdmVyc2lvbiA9IHJ1bnRpbWVWZXJzaW9uVG9VcmxWZXJzaW9uKG1heWJlU3RyaXBlLnZlcnNpb24pO1xuICB2YXIgZXhwZWN0ZWRWZXJzaW9uID0gUkVMRUFTRV9UUkFJTjtcblxuICBpZiAoaXNUZXN0S2V5ICYmIHZlcnNpb24gIT09IGV4cGVjdGVkVmVyc2lvbikge1xuICAgIGNvbnNvbGUud2FybihcIlN0cmlwZS5qc0BcIi5jb25jYXQodmVyc2lvbiwgXCIgd2FzIGxvYWRlZCBvbiB0aGUgcGFnZSwgYnV0IEBzdHJpcGUvc3RyaXBlLWpzQFwiKS5jb25jYXQoXCI3LjQuMFwiLCBcIiBleHBlY3RlZCBTdHJpcGUuanNAXCIpLmNvbmNhdChleHBlY3RlZFZlcnNpb24sIFwiLiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBodHRwczovL2RvY3Muc3RyaXBlLmNvbS9zZGtzL3N0cmlwZWpzLXZlcnNpb25pbmdcIikpO1xuICB9XG5cbiAgdmFyIHN0cmlwZSA9IG1heWJlU3RyaXBlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIHJlZ2lzdGVyV3JhcHBlcihzdHJpcGUsIHN0YXJ0VGltZSk7XG4gIHJldHVybiBzdHJpcGU7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuXG52YXIgc3RyaXBlUHJvbWlzZTtcbnZhciBsb2FkQ2FsbGVkID0gZmFsc2U7XG5cbnZhciBnZXRTdHJpcGVQcm9taXNlID0gZnVuY3Rpb24gZ2V0U3RyaXBlUHJvbWlzZSgpIHtcbiAgaWYgKHN0cmlwZVByb21pc2UpIHtcbiAgICByZXR1cm4gc3RyaXBlUHJvbWlzZTtcbiAgfVxuXG4gIHN0cmlwZVByb21pc2UgPSBsb2FkU2NyaXB0KG51bGwpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgLy8gY2xlYXIgY2FjaGUgb24gZXJyb3JcbiAgICBzdHJpcGVQcm9taXNlID0gbnVsbDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9KTtcbiAgcmV0dXJuIHN0cmlwZVByb21pc2U7XG59OyAvLyBFeGVjdXRlIG91ciBvd24gc2NyaXB0IGluamVjdGlvbiBhZnRlciBhIHRpY2sgdG8gZ2l2ZSB1c2VycyB0aW1lIHRvIGRvIHRoZWlyXG4vLyBvd24gc2NyaXB0IGluamVjdGlvbi5cblxuXG5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdldFN0cmlwZVByb21pc2UoKTtcbn0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gIGlmICghbG9hZENhbGxlZCkge1xuICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gIH1cbn0pO1xudmFyIGxvYWRTdHJpcGUgPSBmdW5jdGlvbiBsb2FkU3RyaXBlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgbG9hZENhbGxlZCA9IHRydWU7XG4gIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpOyAvLyBpZiBwcmV2aW91cyBhdHRlbXB0cyBhcmUgdW5zdWNjZXNzZnVsLCB3aWxsIHJlLWxvYWQgc2NyaXB0XG5cbiAgcmV0dXJuIGdldFN0cmlwZVByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChtYXliZVN0cmlwZSkge1xuICAgIHJldHVybiBpbml0U3RyaXBlKG1heWJlU3RyaXBlLCBhcmdzLCBzdGFydFRpbWUpO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGxvYWRTdHJpcGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@stripe/stripe-js/lib/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@stripe/stripe-js/lib/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadStripe: () => (/* reexport safe */ _dist_index_mjs__WEBPACK_IMPORTED_MODULE_0__.loadStripe)\n/* harmony export */ });\n/* harmony import */ var _dist_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/index.mjs */ \"(ssr)/./node_modules/@stripe/stripe-js/dist/index.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dydXBvdmlzaW9uYXJpb3MvLi9ub2RlX21vZHVsZXMvQHN0cmlwZS9zdHJpcGUtanMvbGliL2luZGV4Lm1qcz85OTk2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2Rpc3QvaW5kZXgubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@stripe/stripe-js/lib/index.mjs\n");

/***/ })

};
;